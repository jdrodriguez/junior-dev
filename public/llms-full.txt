# The Junior Developer Guidebook

> An A-to-Z guide to building modern web apps with AI, written by a dad for his son. Covers the complete journey from zero to deploying real full-stack applications using Claude Code, Next.js, React, Supabase, Hono, and TypeScript. Focuses on conceptual understanding over memorization, using analogies, embedded videos, and practical prompts for AI-assisted development ("vibe coding").

The guidebook is structured as 10 sequential chapters, each building on the last. It teaches web development fundamentals through a "vibe coding" philosophy -- understanding concepts well enough to direct AI tools like Claude Code, rather than memorizing syntax. The tech stack covered is Next.js (React), Supabase (PostgreSQL), Hono (API framework), and TypeScript.

## Welcome to Software Development

Hey. If you're reading this, you're about to pick up one of the most valuable skills a person can have in the modern world: the ability to build software. Not just "learn to code" in the abstract, homework-problem sense -- but actually build things. Real web applications that real people can open on their phones and use.

This guide is written by your dad. I build software for a living, and I want to teach you everything I know -- from the ground up, in the order that actually makes sense, without skipping the stuff that matters.

### Why Now Is the Best Time to Start

We're living in a genuinely extraordinary moment. AI tools like Claude Code have fundamentally changed what it means to be a developer. Previous generations had to memorize syntax, wrestle with cryptic error messages alone, and spend hours on Stack Overflow piecing together answers from strangers. You get to skip a lot of that pain.

But here's the key: **AI doesn't replace understanding.** It amplifies it. The developers who thrive with AI tools are the ones who understand what they're asking for and can evaluate whether the answer is good. That's exactly what this guide will give you.

Imagine a chef who gets an incredibly talented kitchen robot. The robot can chop, saute, plate -- it can do almost anything. But if the chef doesn't understand what "reduce the sauce" means, or what flavors go together, or when something is overcooked, the robot is useless. Worse, it might confidently serve garbage. You're the chef. Claude Code is the robot. This guide teaches you to be the chef.

### What You'll Learn

This guide covers the complete journey. Here's the roadmap:

- **Dev Environment:** Set up your tools: VS Code, the terminal, Node.js, Git, and Claude Code.
- **How the Web Works:** Understand clients, servers, HTTP, and what actually happens when you visit a URL.
- **JavaScript & TypeScript:** Learn the language of the web -- the one language that runs everywhere.
- **Git & GitHub:** Track every change to your code and never lose work again.
- **React & Next.js:** Build interactive user interfaces out of reusable components.
- **Databases & Supabase:** Store, query, and manage data with a real PostgreSQL database.
- **APIs with Hono:** Build the backend logic that powers your applications.
- **Claude Code:** Master your AI pair programmer and multiply your productivity.
- **Deployment:** Put your app on the internet for anyone in the world to use.
- **Developer Mindset:** Learn to think, debug, and solve problems like a professional.

### The Tech Stack (Your Toolkit)

A "tech stack" is just the set of technologies you use to build an app. Here's ours, and why each piece matters:

Think of building a web app like opening a restaurant. **Next.js** is the dining room -- it's what customers see and interact with. **Hono** is the kitchen -- it handles orders, processes them, and sends back results. **Supabase** is the pantry and the filing cabinet -- it stores all your ingredients (data) and keeps track of who's allowed in (authentication). And **Claude Code** is like having a seasoned sous-chef who can help with every station.

- **Next.js and React:** The frontend framework. This is what users see and interact with in their browser. React lets you build UIs out of reusable pieces called components, and Next.js adds powerful features like server-side rendering and file-based routing.

- **Supabase:** Your database and authentication layer. It's built on PostgreSQL (a battle-tested database that runs half the internet) and gives you user login, file storage, and real-time data out of the box.

- **Hono:** A fast, lightweight framework for building your backend API. When your frontend needs data or needs to do something (like create a user account), it talks to your Hono API.

- **Claude Code:** Your AI pair programmer. It lives in your terminal, reads your entire codebase, and can write code, create files, run commands, and build features from plain English descriptions.

### How to Use This Guide

Work through the chapters in order. Each one builds on the last. Don't try to memorize anything -- instead, focus on understanding the *why* behind things. When you understand the concept, the details are easy to look up (or ask Claude Code about).

You do not need to memorize everything in this guide. Seriously. I've been a developer for years and I still Google stuff every single day. Software development isn't about having a perfect memory -- it's about understanding how things fit together and knowing how to find answers when you need them. Read a chapter, then immediately try building something with what you learned. That's how it sticks.

### Ready?

In the next chapter, you'll set up your development environment -- the tools you'll use every day as a developer. It takes about an hour, and by the end of it, your computer will be ready to build anything.

Let's go.

## Setting Up Your Dev Environment

Before you write a single line of code, you need to set up your workstation. This chapter is about getting the right tools installed and configured so that everything else in this guide goes smoothly.

Imagine a carpenter about to build a bookshelf. Before they cut a single piece of wood, they organize their workshop. They make sure the table saw is set up, the drill bits are sorted, the measuring tape is within reach, and the workbench is clear. A messy workshop means mistakes, frustration, and wasted time. A clean one means you can focus entirely on the craft. Your development environment is your workshop. Let's set it up right.

### What We're Setting Up

Here's every tool you'll install in this chapter, and what it does:

- **VS Code:** Your code editor -- the main place where you'll read, write, and navigate code. Think of it as your workbench.
- **The Terminal:** A text-based way to control your computer. Instead of clicking through menus, you type commands. It's faster and more powerful.
- **Node.js & npm:** The engine that runs JavaScript outside a browser, plus a package manager that lets you install thousands of pre-built code libraries.
- **Git:** Version control -- it tracks every change you make to your code so you can go back in time if something breaks.
- **Claude Code:** Your AI pair programmer. It lives in the terminal and can help you write code, debug problems, and build features from natural language.

### How Long Will This Take?

Plan for about **45 minutes to an hour**. Some of these installations require downloads, so your internet speed will be a factor. Don't rush it -- getting your environment right now prevents a lot of headaches later.

If something goes wrong during installation (and it might -- every computer is a little different), don't panic. Copy the error message and ask Claude Code or paste it into Google. Installation issues are one of the most common things developers deal with, and the fix is almost always a quick search away.

### Let's Get Started

Work through each section in order. By the end of this chapter, your computer will be a fully equipped development machine.

## VS Code: Your Code Editor

A code editor is the single most important tool in your development setup. It's where you'll spend the vast majority of your time -- reading code, writing code, navigating between files, and hunting down bugs. Choosing a good one matters.

If your development environment is a carpenter's workshop, VS Code is the workbench. It's the big, central surface where all the actual work happens. You could technically write code in Notepad or TextEdit, the same way a carpenter could technically sand a board on the floor. But a proper workbench has clamps to hold things in place, drawers for your tools, and a flat surface that's the right height. VS Code is that workbench -- built specifically for the job, with everything in reach.

Visual Studio Code (usually just called "VS Code") is the code editor used by the vast majority of professional web developers. It's free, it's fast, and it's wildly extensible -- meaning you can add features to it like apps on a phone. It's made by Microsoft, and it's not the same thing as "Visual Studio" (which is a much heavier, different product).

### Installing VS Code

1. **Go to [code.visualstudio.com](https://code.visualstudio.com)** and click the big download button. It should automatically detect your operating system (Mac, Windows, or Linux).

2. **Run the installer.** On Windows, make sure to check the boxes for "Add to PATH" and "Register as default editor for supported file types." On Mac, drag the app into your Applications folder.

3. **Open VS Code.** You should see a Welcome tab. Take a moment to look around -- notice the sidebar on the left, the editor area in the center, and the bottom bar showing information about your workspace.

That's it. You now have a professional-grade code editor on your machine.

### Essential Extensions

Extensions are add-ons that give VS Code new abilities. Think of them like apps for your editor. To install them, click the Extensions icon in the left sidebar (it looks like four small squares) and search by name.

Here are the ones you should install right away, and more importantly, *why* each one matters:

**ESLint** -- This is your spell-checker for code. Just like a word processor underlines misspelled words, ESLint underlines JavaScript and TypeScript mistakes *as you type*. It catches things like using a variable you never defined, or forgetting a return statement. Without it, you'd only discover these errors when you try to run your code and it crashes.

**Prettier** -- This automatically formats your code to look clean and consistent every time you save. Indentation, spacing, quote styles -- Prettier handles all of it. This means you never have to argue about code style (even with yourself), and your code always looks professional.

**GitLens** -- When you're working on a project over time (or with other people), you'll sometimes look at a line of code and wonder, "Who wrote this? When? Why?" GitLens answers all of those questions. It shows the history of every line right inside the editor.

**Error Lens** -- By default, VS Code puts error indicators in the gutter (the narrow column on the left), which is easy to miss. Error Lens displays the actual error message *inline*, right next to the line that's broken. It makes problems impossible to ignore.

**Auto Rename Tag** -- When you're writing HTML or JSX (which you'll do a lot in React), tags come in pairs: an opening tag and a closing tag. This extension automatically renames the closing tag when you change the opening one, saving you from a very common and annoying bug.

**Tailwind CSS IntelliSense** -- Tailwind is the CSS framework we'll use to style our apps. This extension gives you autocomplete suggestions for Tailwind classes as you type, so you don't have to memorize hundreds of class names.

**Thunder Client** -- When you build APIs (the backend of your app), you need a way to test them. Thunder Client lets you send HTTP requests directly from VS Code, so you can test your API endpoints without leaving your editor.

Don't install dozens of extensions right away. These seven are plenty to start with. Too many extensions can slow down VS Code and create confusing behavior. You can always add more later when you have a specific need.

### Key Settings to Configure

Open VS Code settings with the keyboard shortcut below, then search for each setting:

- **Format On Save:** Turn this on. It tells VS Code to automatically run Prettier every time you save a file. This is one of those "set it and forget it" things that will keep your code clean without any effort.
- **Default Formatter:** Set this to Prettier. This tells VS Code which formatter to use when you hit save.
- **Tab Size:** Set this to 2. The JavaScript and TypeScript community uses 2-space indentation as the standard. You'll want your code to match what you see in tutorials and documentation.

### Keyboard Shortcuts Worth Learning

You don't need to memorize all of these today. But bookmark this table and come back to it. Learning even a few of these will noticeably speed up your workflow.

**Mac:**

| Action | Shortcut |
|--------|----------|
| Open Command Palette | `Cmd + Shift + P` |
| Quick Open File | `Cmd + P` |
| Toggle Terminal | `` Cmd + ` `` |
| Find in All Files | `Cmd + Shift + F` |
| Go to Definition | `F12` |
| Select Next Occurrence | `Cmd + D` |
| Comment / Uncomment Line | `Cmd + /` |
| Move Line Up / Down | `Option + Up/Down` |
| Duplicate Line | `Shift + Option + Down` |

**Windows / Linux:**

| Action | Shortcut |
|--------|----------|
| Open Command Palette | `Ctrl + Shift + P` |
| Quick Open File | `Ctrl + P` |
| Toggle Terminal | `` Ctrl + ` `` |
| Find in All Files | `Ctrl + Shift + F` |
| Go to Definition | `F12` |
| Select Next Occurrence | `Ctrl + D` |
| Comment / Uncomment Line | `Ctrl + /` |
| Move Line Up / Down | `Alt + Up/Down` |
| Duplicate Line | `Shift + Alt + Down` |

The most important one to remember right now is **Command Palette** (`Cmd+Shift+P` on Mac, `Ctrl+Shift+P` on Windows). It's like a search bar for everything VS Code can do. If you ever forget how to do something, open the Command Palette and start typing.

### Let Claude Code Help You

Once Claude Code is installed (we'll get there later in this chapter), you can use it to customize VS Code even further.

## The Terminal

The terminal is one of those things that looks intimidating the first time you see it -- a blank screen with a blinking cursor, waiting for you to type something. No buttons, no menus, no icons. Just you and the command line.

But here's the truth: the terminal is one of the most powerful tools you'll ever learn. Every professional developer uses it daily. And once you get comfortable with a handful of commands, you'll wonder how you ever got by without it.

Normally, you interact with your computer by clicking things -- icons, menus, buttons. That's like communicating through a picture menu at a restaurant: point at what you want. The terminal is like learning the language instead. You can say exactly what you want, combine requests, automate repetitive tasks, and do things that the graphical interface simply doesn't offer. It's slower at first (like learning any language), but once you're conversational, it's dramatically faster and more powerful than pointing and clicking.

### Where to Find the Terminal

You already have a terminal built right into VS Code. Press `` Cmd+` `` on Mac or `` Ctrl+` `` on Windows/Linux (that's the backtick key, above Tab) to toggle it open. You'll see it appear at the bottom of your editor window.

On Mac, you also have a standalone app called **Terminal** (find it in Applications > Utilities). On Windows, you have **PowerShell** and **Command Prompt**, but I'd recommend installing **Windows Terminal** from the Microsoft Store for a better experience.

For this guide, we'll mostly use the VS Code integrated terminal. It's convenient because it automatically opens in your project's folder.

### Essential Commands

You don't need to memorize dozens of commands. Here are the ones you'll actually use every day. The rest you can look up when you need them.

**Mac / Linux:**

| Command | What It Does | Example |
|---------|-------------|---------|
| `pwd` | Shows your current location (Print Working Directory) | `pwd` |
| `ls` | Lists files and folders in the current directory | `ls` |
| `ls -la` | Lists *everything*, including hidden files, with details | `ls -la` |
| `cd folder-name` | Moves into a folder | `cd my-project` |
| `cd ..` | Moves up one level | `cd ..` |
| `cd ~` | Goes to your home directory | `cd ~` |
| `mkdir name` | Creates a new folder | `mkdir my-app` |
| `touch name` | Creates a new empty file | `touch index.js` |
| `rm file` | Deletes a file (no recycle bin!) | `rm old-file.txt` |
| `rm -rf folder` | Deletes a folder and everything inside it | `rm -rf temp` |
| `cat file` | Displays the contents of a file | `cat package.json` |
| `clear` | Clears the terminal screen | `clear` |
| `code .` | Opens the current folder in VS Code | `code .` |

**Windows (PowerShell):**

| Command | What It Does | Example |
|---------|-------------|---------|
| `pwd` | Shows your current location | `pwd` |
| `dir` or `ls` | Lists files and folders | `dir` |
| `cd folder-name` | Moves into a folder | `cd my-project` |
| `cd ..` | Moves up one level | `cd ..` |
| `cd ~` | Goes to your home directory | `cd ~` |
| `mkdir name` | Creates a new folder | `mkdir my-app` |
| `New-Item name` | Creates a new empty file | `New-Item index.js` |
| `Remove-Item file` | Deletes a file | `Remove-Item old-file.txt` |
| `Remove-Item -Recurse folder` | Deletes a folder and contents | `Remove-Item -Recurse temp` |
| `Get-Content file` or `cat file` | Displays file contents | `cat package.json` |
| `cls` or `clear` | Clears the terminal screen | `cls` |
| `code .` | Opens the current folder in VS Code | `code .` |

:::caution
The `rm` command (and `Remove-Item` on Windows) permanently deletes files. There's no recycle bin, no undo. Always double-check what you're deleting before you press Enter. This is one area where the terminal's power can bite you.
:::

### Understanding Where You Are

The single most important concept in the terminal is **your current directory**. Every command you run happens *relative to where you currently are* in the file system. If you're in the wrong folder, commands will fail or affect the wrong files.

Think of it like being inside a building. If someone says "go to Room 3," you need to know which floor you're on first. `pwd` tells you which floor (directory) you're on. `ls` shows you what's in the room. `cd` lets you walk to another room.

When you're lost, run `pwd` to get your bearings. It's the terminal equivalent of looking at the "You Are Here" dot on a mall map.

Here's a practical workflow that will become second nature: when you open a new terminal and want to work on a project, type `cd ` (with a space), then drag the project folder from Finder (Mac) or File Explorer (Windows) directly into the terminal window. It will paste the full path for you. Hit Enter, and you're there. No need to type long folder paths by hand.

### Practice Over Memorization

You don't need to memorize these commands right now. You need to *use* them. Open your terminal and try this:

1. Run `pwd` to see where you are.
2. Run `ls` to see what's in that directory.
3. Run `mkdir practice-folder` to create a new folder.
4. Run `cd practice-folder` to move into it.
5. Run `pwd` again -- notice how your location changed.
6. Run `cd ..` to go back up.
7. Run `rm -rf practice-folder` (Mac/Linux) or `Remove-Item -Recurse practice-folder` (Windows) to clean up.

That's it. You just navigated the file system, created a folder, moved in and out of it, and cleaned it up. Every terminal interaction is just combinations of these basic moves.

### Let Claude Code Help You

The terminal is also where Claude Code lives. Once it's installed, you can ask it to run commands for you or explain what a command does.

## Node.js and npm

JavaScript was originally built to run only inside web browsers. That was great for making websites interactive, but it meant you couldn't use JavaScript to build servers, command-line tools, or anything outside the browser.

**Node.js** changed that. It's a runtime that lets JavaScript run anywhere -- on your computer, on a server, anywhere. When you install Node.js, you're essentially teaching your computer to speak JavaScript.

And bundled with Node.js comes **npm** (Node Package Manager), which is how you install other people's code into your projects.

You know how your phone has an app store where you can download apps that other people built? npm is exactly that, but for code. Need to send emails? There's a package for that. Need to resize images? Package for that. Need a full web framework? Package for that too. Instead of building everything from scratch, you install packages -- pre-built solutions that thousands of other developers have already tested and refined. There are over two million packages on npm. Whatever you need, someone has probably already built it.

### Installing Node.js (and npm)

npm comes automatically with Node.js, so you only need one installation.

1. **Go to [nodejs.org](https://nodejs.org)** and you'll see two download buttons. Choose the **LTS** (Long Term Support) version. LTS means it's the stable, battle-tested version that most developers and companies use. The "Current" version has newer features but might have bugs that haven't been found yet.

2. **Run the installer** with all the default options. On Windows, if it asks about installing additional tools (like Chocolatey), you can check that box -- it can be helpful later.

3. **Verify the installation.** Open your terminal (remember, `` Cmd+` `` in VS Code) and run these two commands:

```bash
node --version
npm --version
```

Both commands should print a version number (something like `v22.x.x` for Node and `10.x.x` for npm). If they do, you're all set. If you get "command not found," try closing and reopening your terminal -- sometimes it needs a fresh start to recognize newly installed programs.

### Understanding package.json

Every JavaScript project has a file called `package.json` at its root. This is one of the most important files in any project, and you'll see it constantly.

Think of `package.json` as a recipe card for your project. It lists all the ingredients (dependencies) your project needs, the instructions for cooking (scripts), and information about the dish itself (name, version, description). If you give someone your recipe card, they can recreate your dish exactly -- by running `npm install`, which reads the recipe and downloads all the ingredients automatically.

Here's what the key parts of a `package.json` file do:

- **name and version:** What your project is called and what version it's on.
- **scripts:** Custom commands you can run. For example, `npm run dev` might start your development server, and `npm run build` might create a production version of your app.
- **dependencies:** Packages your app needs to run (like React, Next.js, etc.).
- **devDependencies:** Packages you only need during development (like TypeScript, testing tools, linters). These don't get shipped to your users.

### The npm Commands You'll Actually Use

You don't need to memorize npm's entire command list. Here are the five commands that cover 95% of what you'll do:

| Command | What It Does |
|---------|-------------|
| `npm install` | Reads `package.json` and downloads all the project's dependencies. Run this when you first clone a project. |
| `npm install package-name` | Adds a new package to your project and saves it in `package.json`. |
| `npm install -D package-name` | Same as above, but saves it as a *dev* dependency (only needed during development). |
| `npm run dev` | Runs the "dev" script from `package.json`. This almost always starts a local development server. |
| `npx command` | Runs a package without permanently installing it. Useful for one-time setup tools. |

:::tip
When you clone a project from GitHub or start following a tutorial, the very first thing you should do is run `npm install` in the project folder. This downloads everything the project needs to work. Without this step, nothing will run.
:::

### The node_modules Folder

When you run `npm install`, it creates a folder called `node_modules` that contains all the downloaded packages. This folder can be enormous -- sometimes hundreds of megabytes. That's normal.

Two important things to know about `node_modules`:

1. **Never edit anything inside it.** These are other people's code. If you change something, it'll get overwritten next time you run `npm install`.
2. **Never commit it to Git.** We'll cover Git soon, but the short version is: `node_modules` is generated from `package.json`, so you don't need to track it. Every project should have a `.gitignore` file that excludes it.

Here's a common beginner mistake: you clone a project, try to run it, and get a bunch of errors. Nine times out of ten, you forgot to run `npm install` first. If something isn't working and you haven't installed the dependencies yet, that's always the first thing to try.

## Installing Git

Git is the version control system used by virtually every software team on the planet. We're going to do a deep dive into how Git works in Chapter 4, so this section is short -- just enough to get it installed and configured so it's ready when you need it.

You know how in video games, you save your progress before a tough boss fight? That way, if things go badly, you can reload from your save point instead of starting the whole game over. Git does the same thing for your code. Every time you make a "commit" (a save point), Git takes a snapshot of your entire project. If you break something later, you can rewind to any previous snapshot. And unlike a video game with limited save slots, Git keeps every snapshot forever.

For now, all you need to know is this: Git tracks changes to your files over time, lets you go back to any previous version, and makes it safe to experiment without fear of losing your work. It's one of those tools that seems unnecessary until the first time it saves you -- and then you'll never code without it.

### Installing Git

**Mac:**

Git might already be installed on your Mac. Open the terminal and run:

```bash
git --version
```

If you see a version number, you're good. If not, macOS will prompt you to install the Command Line Developer Tools -- say yes, and Git will be included.

Alternatively, if you installed Homebrew (a Mac package manager), you can run:

```bash
brew install git
```

**Windows:**

1. Go to [git-scm.com](https://git-scm.com) and download the Windows installer.
2. Run the installer. The defaults are fine for most options. When it asks about the default editor, you can select VS Code if it's listed.
3. When it asks about adjusting your PATH, choose "Git from the command line and also from 3rd-party software."

After installation, open a new terminal and verify:

```powershell
git --version
```

**Linux:**

Use your distribution's package manager:

```bash
# Ubuntu / Debian
sudo apt install git

# Fedora
sudo dnf install git
```

Verify with:

```bash
git --version
```

### Configure Your Identity

Git tags every save point (commit) with your name and email address, so you (and anyone else on the team) can see who made each change. Run these two commands, replacing the placeholder text with your actual name and email:

```bash
git config --global user.name "Your Name"
git config --global user.email "your.email@example.com"
```

This is a one-time setup. Git will remember these settings for all of your projects.

Use the same email address you plan to use for your GitHub account. GitHub uses the email in your Git config to connect commits to your profile. If they don't match, your contributions won't show up on your GitHub activity graph -- which you'll want to start building up.

### That's It (For Now)

We'll cover branches, commits, pull requests, and everything else Git can do in Chapter 4. For now, you just need it installed and configured with your identity.

## Installing Claude Code

This is the tool that changes everything.

Claude Code is an AI pair programmer made by Anthropic. It runs in your terminal and can read your entire codebase, write code, create and edit files, run commands, debug errors, and help you build features from plain English descriptions. It's not a chatbot that gives you generic code snippets -- it's an agent that understands the context of *your* specific project and acts on it.

Imagine you could hire a senior developer -- someone with years of experience across dozens of programming languages and frameworks -- to sit right next to you while you work. You could ask them anything: "Why isn't this working?", "How should I structure this?", "Write the database query for this feature." They'd look at your actual code, understand your project's architecture, and give you answers that fit your specific situation. That's what Claude Code is. Except it never gets tired, never gets annoyed by "dumb" questions, and it's available 24/7.

### What Makes Claude Code Different

There are lots of AI coding tools out there, so it's worth understanding why we're using this one:

- **It lives in your terminal.** Not in a browser tab, not in a sidebar. It runs right where you run your other dev commands, which means it can directly create files, run your tests, start your dev server, and interact with your project.
- **It reads your whole codebase.** Claude Code doesn't just see the one file you paste in. It can explore your entire project structure, understand how files relate to each other, and make changes that are consistent with your existing code.
- **It takes action.** You can ask Claude Code to not just *suggest* code, but actually write files, install packages, run commands, and make changes. It's the difference between a consultant who writes a report and a contractor who does the work.

### Installing Claude Code

You need Node.js and npm installed first (which you should have from the previous section). Claude Code is installed as a global npm package.

1. **Open your terminal** and run:

   ```bash
   npm install -g @anthropic-ai/claude-code
   ```

   The `-g` flag means "global" -- it installs Claude Code as a system-wide command, not just for one project.

2. **Navigate to any project folder** (or create one for testing):

   ```bash
   mkdir test-project
   cd test-project
   ```

3. **Start Claude Code** by simply typing:

   ```bash
   claude
   ```

4. **Authenticate.** On first run, Claude Code will ask you to log in with your Anthropic account. Follow the prompts -- it will open a browser window where you can sign in.

Once authenticated, you'll see Claude Code's prompt waiting for your input. Type a question or instruction in plain English, and it will respond.

### A Quick Verification

Let's make sure everything is working. With Claude Code running in your test project, try typing:

```
What files are in this directory? Create a simple index.html file that says "Hello, World!"
```

Claude Code should look at your directory, note that it's empty (or nearly so), and create the file for you. If it does, everything is working perfectly.

This tool is going to be your most-used development companion, and it's honestly the reason I think now is the best time in history to learn to code. Previous generations had to figure out everything by reading documentation and trial-and-error. You get to have a conversation with an expert. But remember the chef analogy from the introduction: Claude Code is most powerful when *you* understand what you're asking for. That's why we're learning the fundamentals first. The AI amplifies your knowledge -- the more you know, the more it can do for you.

### What's Coming in Chapter 8

We'll dedicate an entire chapter to using Claude Code effectively -- writing great prompts, understanding its limitations, reviewing its output, and building complete features with it. For now, just make sure it's installed and authenticated.

Think of this section as plugging in the power tool. Chapter 8 is where you learn to use it like a pro.

## How the Web Works

Before you build anything on the web, you need to understand what the web *is*. Not at a deep technical level -- just enough to have a mental picture of what happens when someone types a URL into their browser and hits Enter.

This chapter gives you that mental picture.

### What You Will Learn

Every time you visit a website, a quiet conversation is happening between your computer and another computer somewhere in the world. Your browser asks for something. A server responds. That cycle -- request and response -- is the foundation of everything we build.

In this chapter, we will cover:

- **Client-Server Model** -- The two sides of every web conversation
- **HTTP** -- The language browsers and servers speak
- **HTML, CSS, and JavaScript** -- The three building blocks of every web page
- **JSON** -- How data gets packaged and shipped between systems
- **APIs** -- How different pieces of software connect and talk to each other

You do not need to memorize any of this. The goal is to build an intuition. When you hear terms like "API" or "HTTP request" later, you want a picture in your head -- not a textbook definition. That intuition is what separates someone who can vibe code effectively from someone who is just guessing.

### Why This Matters for Vibe Coding

When you are working with Claude Code, you will constantly be asking it to "fetch data from the API" or "send a POST request" or "display this JSON." If you have no idea what those words mean, Claude Code's responses will feel like magic -- and when magic breaks, you have no way to fix it.

Understanding these fundamentals turns magic into machinery. And machinery you can debug.

Let's start with the basics.

## The Client-Server Model

Every time you open a website, two computers are having a conversation. Your computer asks a question. Another computer answers it. That is the entire internet in one sentence.

### The Restaurant Analogy

Imagine you are sitting in a restaurant.

- **You** are the **client**. You look at the menu, decide what you want, and place an order.
- **The kitchen** is the **server**. It receives your order, prepares the food, and sends it back out.
- **The waiter** is **HTTP** -- the protocol that carries your request to the kitchen and brings the response back to your table.

You never walk into the kitchen yourself. You never shout your order across the room. There is a system. The waiter takes your order (the *request*), delivers it to the kitchen, and comes back with your plate (the *response*).

That is exactly how the web works. Your browser is you at the table. The server is the kitchen. And HTTP is the waiter carrying messages back and forth.

### How It Actually Works

When you type `google.com` into your browser and press Enter, here is what happens:

1. **Your browser (the client)** creates a request: "Hey, I want the Google homepage."
2. **That request travels across the internet** to one of Google's servers -- a powerful computer sitting in a data center somewhere.
3. **The server processes the request** and builds a response: the HTML, CSS, and JavaScript that make up the Google homepage.
4. **The response travels back** to your browser.
5. **Your browser renders it** -- turning that code into the visual page you see on screen.

This round trip happens every single time you click a link, submit a form, or load new data. It is called the **request-response cycle**, and it is the heartbeat of every web application.

### Frontend and Backend

When you build a full-stack application, you are building both sides of this conversation:

- **The frontend** is everything the user sees and interacts with -- buttons, forms, pages, animations. This runs in the browser (the client).
- **The backend** is the behind-the-scenes logic -- handling requests, talking to the database, running business rules. This runs on the server.

In our stack, React and Next.js handle the frontend. Hono and Supabase handle the backend. But they all communicate through this same request-response pattern.

Here is a good way to remember it: if you can see it on screen, it is frontend. If it is happening behind the scenes, it is backend. When you tell Claude Code to "build a form that saves to the database," you are asking it to build both sides -- the form the user sees (frontend) and the logic that stores the data (backend).

## HTTP: The Language of the Web

Remember the waiter from our restaurant analogy? HTTP (HyperText Transfer Protocol) is that waiter. It is the agreed-upon language that browsers and servers use to communicate. Every request your browser sends and every response the server returns follows HTTP rules.

You do not need to memorize the entire HTTP specification. You need to understand two things: **methods** and **status codes**.

### HTTP Methods: What Do You Want to Do?

Every HTTP request includes a *method* -- a verb that tells the server what kind of action you are requesting.

Think of your server as a library, and HTTP methods are the different things you can do there:

- **GET** -- "I want to *borrow* a book." You are asking for information. Nothing changes on the shelf.
- **POST** -- "I want to *donate* a new book." You are giving the library something it did not have before.
- **PUT** -- "I want to *replace* this old edition with a new one." You are updating something that already exists by swapping it entirely.
- **DELETE** -- "I want to *remove* this book from the catalog." You are asking for something to be taken away.

Most of what you do on the web boils down to these four actions. Loading a page? That is a GET. Submitting a sign-up form? That is a POST. Editing your profile? That is a PUT. Removing a to-do item? That is a DELETE.

### Status Codes: What Happened?

After the server processes your request, it sends back a status code -- a number that tells you how things went. Think of them as report cards.

Every time you ask the server for something, it hands you back a grade:

- **200 -- "A+ Great job."** Everything worked perfectly. Here is what you asked for.
- **201 -- "A, Created."** You asked me to make something new, and I did. Success.
- **400 -- "D, Bad Request."** I could not understand what you were asking. Check your work.
- **401 -- "Unauthorized."** You did not show your hall pass. Log in first.
- **403 -- "Forbidden."** I know who you are, but you do not have permission for this.
- **404 -- "Not Found."** I looked everywhere. That thing does not exist.
- **500 -- "School burned down."** Something went very wrong on my end. Not your fault.

Here is a quick rule of thumb:

- **2xx** codes mean **success**. The server did what you asked.
- **4xx** codes mean **you made a mistake**. Bad URL, missing login, wrong data.
- **5xx** codes mean **the server made a mistake**. Something broke on their end.

When you are debugging and see a 404, it almost always means the URL is wrong -- a typo in the path or a route that does not exist yet. A 500 means something crashed on the server side and you need to check the server logs. These numbers become second nature very quickly.

### Why This Matters for You

When you build an API with Hono later in this book, you will be deciding which methods your endpoints accept and which status codes they return. When your React frontend calls those endpoints, it will check the status code to know what to display: the data, an error message, or a "please log in" screen.

You do not need to build HTTP from scratch. Frameworks handle the wiring. But understanding the vocabulary means you can read error messages, debug problems, and tell Claude Code exactly what you need.

## HTML, CSS, and JavaScript: The Three Pillars

Every web page you have ever visited -- from Google to YouTube to that weird fan wiki -- is built with the same three technologies. They have different jobs, and understanding what each one does gives you a mental model for everything else in web development.

### The Human Body Analogy

Think of a web page as a person:

- **HTML is the skeleton.** It defines the structure -- what things exist on the page. A heading here, a paragraph there, a button over there, an image at the top. Without HTML, there is nothing.
- **CSS is the skin, clothes, and style.** It defines how things look -- colors, fonts, spacing, layout. Two pages can have the exact same HTML but look completely different because of CSS. Same skeleton, different outfits.
- **JavaScript is the muscles and brain.** It defines behavior -- what happens when you click a button, how a form validates your input, how new data loads without refreshing the page. It makes things *move* and *respond*.

### HTML: The Structure

HTML (HyperText Markup Language) tells the browser *what* is on the page. It uses tags -- special labels wrapped in angle brackets -- to define elements:

- A heading
- A paragraph of text
- A button you can click
- An image
- A form with input fields

Think of HTML as writing an outline. You are not worrying about colors or animations yet. You are just declaring: "This page has a title, three paragraphs, and a submit button."

### CSS: The Style

CSS (Cascading Style Sheets) tells the browser *how things look*. Once HTML lays out the skeleton, CSS dresses it up:

- What color is the text?
- How much space is between elements?
- Should this layout be a grid or a single column?
- What font should the headings use?
- How wide should this container be on a phone versus a desktop?

CSS is what makes the difference between a page that looks like a 1995 GeoCities site and a page that looks like a modern app.

### JavaScript: The Behavior

JavaScript tells the browser *what to do* when things happen. It is the programming language of the web:

- When a user clicks "Add to Cart," JavaScript updates the cart counter.
- When you type in a search box, JavaScript filters results in real time.
- When a page loads, JavaScript fetches data from a server and displays it.

JavaScript is the only programming language that runs natively in every web browser. That is why it became the language of the web -- and why we use it (in the form of TypeScript) for our entire stack.

### The Modern Reality

:::tip[You Will Rarely Write Raw HTML or CSS]
In our stack, **React** lets you write HTML-like syntax called JSX directly inside your JavaScript. And **Tailwind CSS** lets you apply styles using short utility classes right in your markup -- no separate CSS files needed.

So in practice, you will be writing something that *looks* like a blend of all three. But under the hood, it is still HTML for structure, CSS for style, and JavaScript for behavior. Understanding the fundamentals helps you make sense of what React and Tailwind are actually doing for you.
:::

You do not need to become an HTML or CSS expert before moving on. The goal right now is to know that every web page has structure, style, and behavior -- and to recognize which layer you are working with when Claude Code generates code for you. If you see angle brackets and tag names, that is the HTML layer. If you see colors, spacing, or layout classes, that is CSS. If you see logic, functions, or event handling, that is JavaScript.

## JSON: How Data Travels

When your frontend needs data from the backend -- a list of users, the details of a product, your account settings -- that data has to travel across the internet. But computers need a standard format to package that data so both sides can understand it.

That format is **JSON** (JavaScript Object Notation).

### The Shipping Label Analogy

Imagine you are shipping a package. You cannot just toss your stuff into a box and hope the delivery driver figures out where it goes. There is a standard format for the label: name, address, city, zip code. Everyone agrees on the format, so any shipping company can read it.

JSON is that standardized label for data. It is a simple, universal format that any programming language can read and write. When your React frontend asks the server for a user's profile, the server packages that data as JSON and ships it back. Your frontend unpacks it and displays it on screen.

### What JSON Looks Like

This is the one code example in this chapter, because you will see JSON constantly and need to recognize it:

```json
{
  "name": "Jordan Rodriguez",
  "age": 16,
  "email": "jordan@example.com",
  "isStudent": true,
  "hobbies": ["coding", "gaming", "basketball"],
  "address": {
    "city": "Austin",
    "state": "TX"
  }
}
```

A few things to notice:

- Everything is wrapped in curly braces `{ }`.
- Data comes in **key-value pairs**: a name on the left, a value on the right, separated by a colon.
- **Strings** (text) are in double quotes.
- **Numbers** and **booleans** (`true`/`false`) are not in quotes.
- **Arrays** (lists) use square brackets `[ ]`.
- **Objects** (nested groups of data) use curly braces `{ }` again.

That is it. That is the entire format. Once you can read this, you can read the data flowing through any web application.

When you are working with Claude Code and it shows you an API response, it will almost always be JSON. Being able to scan JSON and understand the shape of the data -- "okay, it is an object with a name, an age, and a list of hobbies" -- is one of the most useful skills you can have. You do not need to write JSON by hand. You just need to read it.

### Where You Will See JSON

- **API responses:** When your app fetches data from the server, it arrives as JSON.
- **Configuration files:** Many tools use JSON files for settings (like `package.json` in every Node.js project).
- **Database records:** When you pull data from Supabase, it comes back as JSON.
- **Claude Code conversations:** When you ask Claude Code to show you what an API returns, it will show JSON.

## APIs: Connecting Everything

You now know about clients and servers, HTTP methods and status codes, the three pillars of web pages, and JSON. An API is where all of those pieces come together.

**API** stands for Application Programming Interface. That name sounds intimidating, but the concept is simple: an API is a set of rules for how one piece of software talks to another.

### The Restaurant Menu Analogy

You are back at the restaurant. The kitchen (server) can make hundreds of different dishes, but you cannot just walk in and start shouting random requests. You need the **menu**.

The menu is the API. It tells you:
- **What you can order** (the available endpoints, like `/api/users` or `/api/tasks`)
- **How to order it** (which HTTP method to use -- GET to read, POST to create)
- **What you will get back** (the JSON response with your data)

You do not need to know how the kitchen works. You do not need to know the recipes. You just need to read the menu, place your order correctly, and the kitchen handles the rest.

That is exactly what an API does. It is the contract between your frontend and your backend: "If you send me this kind of request, I will send you back this kind of response."

### How the Pieces Connect in Our Stack

In the applications you will build, here is how data flows:

1. **React (Frontend)** -- The user clicks a button or loads a page. React sends an HTTP request to your API. For example: `GET /api/tasks`.

2. **Hono (API Layer)** -- Your Hono server receives the request, figures out what needs to happen (maybe check if the user is logged in, validate some data), and talks to the database.

3. **Supabase (Database)** -- Supabase stores all your data. Hono asks Supabase: "Give me all tasks for this user." Supabase runs the query and returns the results.

4. **The Response** -- Hono packages the data as JSON and sends it back to React with a 200 status code. React receives the JSON and renders it on screen.

That is the full loop. Frontend to API to database and back. Every feature you build follows this pattern.

### APIs Are Everywhere

Your own Hono API is just one example. APIs are how the entire internet connects:

- **Stripe's API** lets your app process payments without building a payment system from scratch.
- **Google's Maps API** lets your app embed maps and calculate directions.
- **GitHub's API** lets tools interact with your repositories programmatically.
- **OpenAI's API** lets your app use AI models.

When someone says "we are going to integrate with Stripe," they mean "we are going to call Stripe's API from our backend." The pattern is always the same: send an HTTP request, get a JSON response.

When you are building features with Claude Code, a lot of what you are doing is wiring up this flow: "When the user does X on the frontend, call this API endpoint, which talks to the database, and display the result." Once this mental model clicks, you can describe almost any feature in those terms -- and Claude Code will understand exactly what you need.

## JavaScript & TypeScript Essentials

JavaScript is the language of the web. Every browser on Earth speaks it. Every website you have ever used runs it. And when you build full-stack applications, you will use it on both the frontend and the backend.

TypeScript is JavaScript with superpowers -- specifically, the ability to define *types* that catch mistakes before your code ever runs. Think of it as spell-check for your code. Our entire stack uses TypeScript, so this chapter covers both.

### What You Will Learn

- **JavaScript Foundations** -- Variables, functions, arrays, and the core concepts you need to read and understand code
- **TypeScript** -- What types are, why they matter, and why you should let TypeScript do most of the work
- **Async/Await** -- How JavaScript handles things that take time, like fetching data from an API

### A Different Kind of Learning

Here is the thing: you do not need to memorize syntax. You are not going to sit down and hand-write a sorting algorithm from memory. That is not how modern development works, and it is definitely not how vibe coding works.

What you *do* need is to understand the **concepts**. When you know what a function is, what an array does, and why async/await exists, you can describe what you want to Claude Code in plain English -- and actually understand what it writes back.

Think of this chapter like learning the rules of basketball. You do not need to memorize every play in the playbook before stepping on the court. But you need to know what dribbling is, what a pass is, and what the three-point line means. The plays come with practice. The concepts come first.

That is what this chapter is about. Concepts, mental models, and just enough vocabulary to have a real conversation with your AI pair programmer.

Let's get into it.

## JavaScript Foundations

You do not need to memorize JavaScript syntax. What you need is a mental model for the core concepts so you can read code that Claude Code generates and understand *what* it is doing and *why*. Here are the building blocks.

### Variables: Labeled Boxes

Imagine a shelf full of boxes. Each box has a label on it and something inside. That is a variable. The label is the name. The thing inside is the value.

- `const userName = "Jordan"` -- a box labeled "userName" with "Jordan" inside. The `const` means this box is sealed shut. You cannot swap what is inside.
- `let score = 0` -- a box labeled "score" with 0 inside. The `let` means this box can be opened and the value changed later. Maybe the score goes up to 10.

You will almost always use `const`. Only use `let` when you know the value needs to change. And never use `var` -- it is the old way and has quirks that cause bugs.

### Data Types: What Goes in the Boxes

JavaScript has a few fundamental types of values:

- **Strings** -- Text. Anything in quotes: `"hello"`, `"Jordan Rodriguez"`, `""`.
- **Numbers** -- Any number: `42`, `3.14`, `-7`.
- **Booleans** -- True or false. That is it. `true` or `false`. Like a light switch: on or off.
- **Null** -- Intentionally empty. You looked in the box and it was deliberately left blank.
- **Undefined** -- Not yet assigned. The box exists but nobody put anything in it.
- **Arrays** -- Ordered lists of things. Like a numbered to-do list.
- **Objects** -- Groups of related data. Like a contact card with a name, email, and phone number.

You do not need to declare types in plain JavaScript (that is TypeScript's job). But you do need to recognize these when you see them in code.

### Functions: Recipes

A function is a recipe. It has a name, takes in ingredients (called *parameters*), follows a set of instructions, and produces a result (called a *return value*).

Think of a function called `makeSmoothie`. You give it bananas, strawberries, and milk (the parameters). It blends them together (the instructions). And it hands you back a smoothie (the return value).

Once you write the recipe, you can use it over and over with different ingredients. That is the power of functions -- write once, reuse everywhere.

In modern JavaScript, functions look like this: `const makeSmoothie = (fruit, liquid) => { ... }`. That arrow (`=>`) is why they are called "arrow functions." You will see them everywhere.

The key ideas to remember:
- Functions take **inputs** (parameters) and produce **outputs** (return values).
- Functions let you **reuse** logic instead of repeating yourself.
- Functions can call other functions, which is how complex programs are built from simple pieces.

### Arrays: Ordered Lists

An array is like a numbered to-do list. Each item has a position (starting from 0, not 1), and you can add, remove, or transform items.

The most common things you will do with arrays:
- **Map** -- Transform every item. "Take my list of names and turn each one into a greeting card."
- **Filter** -- Keep only the items that pass a test. "Show me only the completed tasks."
- **Find** -- Get the first item that matches. "Find the user named Jordan."

These three operations -- map, filter, find -- show up in almost every web application. When Claude Code generates a list of cards on a page, it is almost certainly using `.map()`. When it adds a search feature, it is probably using `.filter()`.

### Objects: Contact Cards

An object groups related data together under one name. Instead of having separate variables for a person's name, age, and email, you bundle them into one object:

Think of it as a contact card. The card is the object. Each field on the card (name, email, phone) is a **property**. You can read any property by name, update it, or add new ones.

Objects and arrays are the two structures you will see most. A list of users? That is an array of objects. A single user's profile? That is an object.

When you are reading code Claude Code writes, you will see a lot of objects and arrays working together. Something like "an array of task objects, where each task has a title, status, and due date." Once you can picture that in your head, you can understand 90% of the data flowing through any web app.

## TypeScript: Adding Superpowers

JavaScript is flexible. *Too* flexible sometimes. It will let you add a number to a string, pass the wrong kind of data to a function, or access a property that does not exist -- and it will not warn you until your app crashes in front of a user.

TypeScript fixes this. It is JavaScript with one crucial addition: **types**.

### The Spell-Check Analogy

You know how your phone underlines misspelled words in red before you send a text? You can still send the text with typos, but the red underline *warns* you first so you can fix it.

TypeScript does the same thing for your code. It reads what you wrote, checks it against the rules you defined, and underlines problems *before* you run anything. Instead of finding out your app is broken when a user clicks a button, you find out while you are still writing.

Plain JavaScript is like texting with autocorrect turned off. TypeScript is like having a smart editor that catches your mistakes in real time.

### What Are Types?

A type tells the computer what kind of value something is and what you can do with it. You already know the basic types from JavaScript -- strings, numbers, booleans. TypeScript just makes you (or lets you) be explicit about them.

Why does this matter? Because it catches entire categories of bugs:

- You accidentally pass a number where a string was expected? TypeScript catches it.
- You try to access `.name` on something that might be `null`? TypeScript warns you.
- You misspell a property name on an object? TypeScript tells you immediately.

These are not hypothetical problems. They are the kinds of bugs that eat hours of debugging time in plain JavaScript. TypeScript eliminates them before you even run your code.

### Interfaces: Blueprints for Objects

Remember how we talked about objects being like contact cards? An **interface** is the blank template for that card. It says: "Every contact card must have a name (string), an email (string), and optionally a phone number (string)."

Once you define that template, TypeScript enforces it. If you try to create a contact card without an email, TypeScript says "hold on -- the blueprint says email is required." If you try to add a field that is not in the blueprint, TypeScript flags it.

Interfaces are blueprints. They define the *shape* of your data so your entire application agrees on what a User, Task, or Product looks like.

When you are working with APIs, interfaces are especially powerful. You define an interface for your API response, and then TypeScript guarantees that every part of your app that handles that response is working with the right shape of data.

### Type Inference: TypeScript Is Smart

Here is the good news: you do not have to type out types for *everything*. TypeScript is remarkably smart about figuring things out on its own. When you write `const name = "Jordan"`, TypeScript already knows that `name` is a string. You did not have to tell it.

This is called **type inference**, and it means you only need to add explicit types in certain places:

- **Function parameters** -- TypeScript cannot guess what you intend to pass in, so you tell it.
- **Function return values** -- Especially for complex functions, being explicit helps.
- **Interfaces** -- When you define the shape of your data structures.

For everything else, let TypeScript figure it out. It is usually right.

When you are starting out, do not obsess over getting types perfect. Seriously. Start by letting TypeScript infer whatever it can. Add explicit types when TypeScript complains or when you are defining function parameters. Claude Code is excellent at helping you write correct types -- just ask it. The goal is to let TypeScript help you, not to fight it.

### Why Our Entire Stack Uses TypeScript

Our stack -- React, Next.js, Hono, Supabase -- all supports TypeScript. That means you get type safety from the frontend to the backend to the database. If you change the shape of your data in one place, TypeScript warns you about every other place that needs to be updated. It is like having a safety net across your entire application.

This is especially powerful when vibe coding. When Claude Code generates code, TypeScript immediately tells you if anything does not fit. It is a second set of eyes that never gets tired.

:::tip[When to Watch the Long One]
The Fireship video gives you the concept in two minutes. The Mosh tutorial is a full hour and walks you through writing actual TypeScript. Watch the short one now. Bookmark the long one for when you are ready to practice hands-on.
:::

## Async/Await: Handling Things That Take Time

Some things in programming happen instantly. Adding two numbers? Done. Checking if a string is empty? Done. But some things take time: fetching data from a server, reading a file, waiting for a user to upload an image. These are called **asynchronous** operations.

JavaScript has a clean way to handle them: **async/await**.

### The Food Delivery Analogy

Imagine you order dinner through a delivery app. You do not stand at the door and stare at it until the food arrives. That would be insane. Instead, you:

1. **Place the order** (start the asynchronous operation).
2. **Go do other things** -- watch TV, do homework, play a game (JavaScript keeps running other code).
3. **Get notified when it arrives** (the operation completes and you get the result).

That is async/await in a nutshell.

- **`async`** marks a function as one that will involve waiting. It is like saying: "This recipe includes a delivery order, so do not expect it to finish instantly."
- **`await`** is the actual waiting. It says: "Pause here until the delivery arrives, then continue with the next step."

Without `await`, JavaScript would just keep going and try to eat dinner before the food shows up. With `await`, it pauses that particular task and picks it up when the data is ready -- while still handling other things in the meantime.

### Why This Matters for Web Development

Almost everything interesting in a web app involves waiting:

- **Fetching data from your API** -- Your frontend asks the backend for a list of tasks. The backend has to talk to the database, package the response, and send it back. That takes time.
- **Saving data to the database** -- The user fills out a form and clicks submit. The app needs to send that data to the server and wait for confirmation.
- **Loading an image** -- The browser downloads an image from a URL. How long that takes depends on the file size and the user's internet speed.
- **Authenticating a user** -- Checking login credentials with an auth service is an asynchronous call.

Every single one of these uses async/await. You will see this pattern hundreds of times.

### The Safety Net: try/catch

What happens if the delivery never shows up? Maybe the restaurant is closed. Maybe there was a network error. You need a plan for when things go wrong.

That is what **try/catch** does. It wraps your async code in a safety net:

- **`try`** -- "Attempt to do this thing."
- **`catch`** -- "If it fails, here is what to do instead."

It is like saying: "Try to order dinner. If the delivery fails, order pizza instead." Without try/catch, a failed API call could crash your entire app. With it, you can show the user a friendly error message, retry the operation, or fall back to cached data.

The pattern looks like this in plain English:

1. **Try** to fetch data from the API.
2. If it **works**, use the data.
3. If it **fails** (catch), show an error message to the user.

You will use this try/catch pattern with almost every async operation. It is not optional -- it is how professional apps handle the reality that things sometimes break.

When you are working with Claude Code and you ask it to fetch data or save something to the database, check that it wraps the code in try/catch. If it does not, ask it to add error handling. This is one of those habits that separates code that works in demos from code that works in the real world.

### The Key Insight

Here is the single most important thing to remember about async/await:

**`await` pauses execution until the asynchronous operation completes.**

That is it. When you see `await fetch(...)`, it means "wait here until the server responds, then continue to the next line." When you see `await supabase.from('tasks').select('*')`, it means "wait here until the database returns the data."

You do not need to understand the entire event loop or JavaScript's concurrency model. You need to know that `await` means "wait for this" and `try/catch` means "handle failures gracefully." With those two concepts, you can read and understand any async code Claude Code generates.

:::tip[This One Is Worth the Full Watch]
This is one of the best explanations of async/await on the internet. Fireship breaks down the concept visually and builds up from callbacks to promises to async/await. If you watch one video in this entire chapter, make it this one.
:::

## Git & GitHub

Git is the tool that tracks every single change you make to your code. GitHub is the website where your code lives online so you can share it, collaborate, and never lose it. Together, they are the backbone of professional software development.

Every developer on the planet uses Git. Every single one. It does not matter if you are building a side project alone in your room or working on a team of 500 engineers at Google -- Git is the system everyone agrees on.

Imagine if every time you wrote an essay, you could save a snapshot of the entire document at any point. Made a mess of paragraph three? Jump back to the version from an hour ago. Want to try a completely different ending without losing what you already have? Create a parallel copy, experiment freely, and merge the good parts back in later. That is exactly what Git does for your code.

### What You Will Learn

- **Core Concepts** -- Repos, commits, branches, merges -- the vocabulary every developer speaks.
- **Essential Workflow** -- The 9-step process you will repeat on every project for the rest of your career.
- **GitHub Setup** -- Create your account, set up SSH keys, and push your first code.
- **Commit Messages** -- Write messages that future-you will actually thank you for.
- **.gitignore** -- Keep secrets and junk out of your repository.
- **Recovery** -- Fix mistakes without panicking. Everyone messes up -- here is how to undo it.

Learning Git will feel weird at first. The commands are not intuitive, and you will mess things up. That is completely normal. I have been using Git for years and I still Google commands sometimes. The difference between a beginner and a pro is not that pros never make mistakes -- it is that they know how to recover from them. This chapter will teach you both.

Let's start with the basics.

## Core Concepts

Before you type a single Git command, you need to understand the vocabulary. These terms will come up every single day once you start building real projects, and they are the same terms used by developers at every company in the world.

### The Video Game Save System

You know how in a video game, you save before a boss fight so you can reload if things go badly? Git is exactly like that, but for your code.

- **Commits** are your save points. Each one captures a snapshot of every file in your project at that exact moment.
- **Branches** are parallel timelines. Imagine you could save your game, then play two completely different paths at the same time -- one where you fight the boss head-on, and another where you sneak around. Branches let you try things without risking your main progress.
- **Merging** is picking the winning timeline and bringing those changes back into your main save file.

The best part? Unlike a video game, you never run out of save slots. You can have hundreds of commits and Git stores them all efficiently.

### Key Terminology

Here are the terms you need to know. Do not try to memorize these all at once -- just read through them and come back as a reference.

- **Repository (repo):** A project folder tracked by Git. It contains all your code *and* its entire history. When you hear someone say "clone the repo," they mean "download the project."
- **Commit:** A snapshot of your code at a specific moment. Every commit has a unique ID, a message describing what changed, and a pointer to the previous commit. Think of it as a save point with a note attached.
- **Branch:** A parallel version of your code. You create branches to work on features without touching the main codebase. When your feature is done, you merge the branch back in.
- **Main (or Master):** The primary branch. This should always contain working, stable code. You never work directly on main -- you create a branch, do your work there, and merge it back.
- **Merge:** Combining changes from one branch into another. When your feature branch is ready, you merge it into main. Git is smart enough to combine the changes automatically most of the time.
- **Pull Request (PR):** A request on GitHub to merge your branch into main. This is where code review happens. Your teammates (or your AI pair programmer) can look at your changes and suggest improvements before they go live.
- **Clone:** Download a complete copy of a repository from GitHub to your computer. This gets you the code *and* all its history.
- **Push & Pull:** **Push** uploads your local commits to GitHub. **Pull** downloads the latest changes from GitHub to your computer. Think of them as "upload" and "download" for your code.

### How It All Fits Together

Here is the big picture of how these concepts connect:

1. You **clone** a repo from GitHub to your computer.
2. You create a **branch** for the feature you are working on.
3. You write code, then **commit** your changes (save points).
4. You **push** your branch to GitHub.
5. You open a **Pull Request** to propose merging your branch into **main**.
6. After review, you **merge** the PR.
7. You **pull** the updated main branch back to your computer.

That is the entire cycle. Every professional developer follows some version of this loop, whether they are building a to-do app or a billion-dollar platform.

Do not stress about understanding every detail right now. The next section walks you through the actual commands step by step. For now, just know that Git is about saving your work, working in parallel safely, and sharing code with others. The rest is just syntax.

## Essential Workflow

This is the workflow you will use on almost every project for the rest of your coding life. It does not matter if you are working alone or on a team of fifty people -- the steps are the same. Memorize this loop.

Think of this workflow like a factory assembly line. Each step happens in order, and skipping a step means the product comes out wrong. You would not try to ship a car before putting the engine in. Same idea -- you would not push code before committing it, and you would not merge before getting a review.

### The 9 Steps

1. **Create a new branch for your feature**

   Never work directly on `main`. Always create a branch first. Name it something descriptive so anyone can tell what you are working on.

   ```bash
   git checkout -b feature/add-login-page
   ```

   The `-b` flag means "create a new branch and switch to it." The name `feature/add-login-page` is a convention -- the `feature/` prefix tells people this branch adds something new.

2. **Write your code**

   This is the fun part. Open your editor, build your feature, and make changes to whatever files you need. Git is watching, but it is not recording anything yet.

3. **Check what files you changed**

   Before you commit, always look at what you changed. This is like reviewing your essay before turning it in.

   ```bash
   git status
   ```

   You will see a list of modified files in red (unstaged) and green (staged). Get in the habit of running this before every commit.

4. **Stage the files you want to commit**

   Staging is like putting files in an envelope before mailing them. You are saying "these are the changes I want to include in my next save point."

   ```bash
   # Stage everything you changed
   git add .

   # Or stage specific files (more precise)
   git add src/login.tsx src/styles/login.css
   ```

   :::tip
   Staging specific files instead of using `git add .` is a good habit. It forces you to think about exactly what you are committing and prevents accidentally including files you did not mean to.
   :::

5. **Commit with a descriptive message**

   Now you are creating the actual save point. The message should explain *what* you did and *why*.

   ```bash
   git commit -m "Add login page with email/password form"
   ```

   We will cover how to write great commit messages in a later section. For now, just be descriptive.

6. **Push your branch to GitHub**

   Upload your local commits so they exist online. This is your backup and your way of sharing work.

   ```bash
   git push origin feature/add-login-page
   ```

   The first time you push a new branch, you might need to use:
   ```bash
   git push -u origin feature/add-login-page
   ```
   The `-u` flag sets up tracking so future pushes are simpler.

7. **Create a Pull Request on GitHub**

   Go to your repository on GitHub. You will see a banner saying "Compare & pull request." Click it, write a description of your changes, and submit the PR.

8. **Review and merge the PR**

   On a team, someone else reviews your code. Working solo or with an AI, you can review it yourself. Once it looks good, click "Merge pull request" on GitHub.

9. **Switch back to main and pull the latest**

   After merging, get your local copy up to date.

   ```bash
   git checkout main
   git pull origin main
   ```

   Now your local `main` matches what is on GitHub, and you are ready to start the cycle over with a new branch.

### Let AI Help You

When you are working with Claude Code, you can ask it to handle Git operations for you. This is a totally valid way to work, especially when you are learning.

Here is the thing about this workflow -- the first few times, it will feel like a lot of steps just to save your code. But I promise, after you do it a dozen times, it becomes muscle memory. You will not even think about it. And the first time Git saves you from losing hours of work, you will understand why every developer on the planet uses it.

:::caution
If you see "merge conflicts" when you pull or merge, do not panic. It just means two people changed the same lines of code, and Git needs you to decide which version to keep. We will cover this more in the recovery section.
:::

## GitHub Setup

GitHub is where your code lives online. Think of it as the cloud storage for your projects, but way more powerful -- it tracks every change, lets people collaborate, and shows the world what you have built. Your GitHub profile will become your developer portfolio, so let's set it up right.

### Step 1: Create Your Account

1. Go to [github.com](https://github.com) and click **Sign Up**.
2. Pick a username you will not be embarrassed by in five years. This will be part of your public profile URL (`github.com/your-username`). Keep it professional-ish. Your real name or a clean handle works great.
3. Use a real email address you check. GitHub will send you verification and notification emails.
4. Complete the setup wizard and verify your email.

### Step 2: Configure Git on Your Computer

Before you push any code, tell Git who you are. This information gets attached to every commit you make.

```bash
git config --global user.name "Your Name"
git config --global user.email "your.email@example.com"
```

Use the same email you signed up with on GitHub so your commits get linked to your profile.

### Step 3: Set Up SSH Authentication

Right now, every time you want to push code to GitHub, you would need to type your username and password. SSH keys fix that. Think of them like a VIP wristband at a concert -- once you set it up, the bouncer (GitHub) recognizes you automatically and lets you through without checking your ID every time.

SSH uses a pair of keys: a **private key** (stays on your computer, never share it) and a **public key** (you give to GitHub). When you push code, your computer proves it has the private key that matches the public key GitHub has on file.

**Mac / Linux:**

```bash
# Generate your SSH key
ssh-keygen -t ed25519 -C "your.email@example.com"
```

Press **Enter** to accept the default file location. Then set a passphrase (or press Enter to skip -- a passphrase adds extra security).

```bash
# Start the SSH agent
eval "$(ssh-agent -s)"

# Add your key to the agent
ssh-add ~/.ssh/id_ed25519

# Copy the public key to your clipboard
pbcopy < ~/.ssh/id_ed25519.pub
```

If `pbcopy` does not work (Linux), use:
```bash
cat ~/.ssh/id_ed25519.pub
```
Then manually select and copy the output.

**Windows:**

Open **Git Bash** (installed with Git for Windows) and run:

```bash
# Generate your SSH key
ssh-keygen -t ed25519 -C "your.email@example.com"
```

Press **Enter** to accept the default file location. Set a passphrase or press Enter to skip.

```bash
# Start the SSH agent
eval "$(ssh-agent -s)"

# Add your key to the agent
ssh-add ~/.ssh/id_ed25519

# Copy the public key to your clipboard
clip < ~/.ssh/id_ed25519.pub
```

If `clip` does not work, use:
```bash
cat ~/.ssh/id_ed25519.pub
```
Then manually select and copy the output.

Now add the key to GitHub:

1. Go to [github.com/settings/keys](https://github.com/settings/keys).
2. Click **New SSH key**.
3. Give it a title like "My Laptop" so you remember which computer it is for.
4. Paste your public key into the **Key** field.
5. Click **Add SSH key**.
6. Test the connection:
   ```bash
   ssh -T git@github.com
   ```
   You should see: "Hi your-username! You've successfully authenticated."

### Step 4: Create Your First Repository

1. On GitHub, click the **+** in the top-right corner and select **New repository**.
2. Name it something simple like `my-first-project`.
3. Add a description: "My first GitHub repository."
4. Choose **Public** (so the world can see your work -- this is good for your portfolio).
5. Check **Add a README file**.
6. Click **Create repository**.
7. Clone it to your computer:
   ```bash
   git clone git@github.com:your-username/my-first-project.git
   cd my-first-project
   ```
8. Open it in your editor and start building.

I know the SSH setup feels like a lot of steps for something that should be simple. Trust me, you only do this once per computer. After that, pushing and pulling code is completely seamless. If you get stuck, ask Claude Code to help -- it is great at walking through setup issues. Every developer has struggled with SSH keys at some point. You are not alone.

:::tip
Bookmark your GitHub profile page (`github.com/your-username`). As you build more projects throughout this book, your profile will fill up with green contribution squares. Future employers and collaborators will look at this.
:::

## Commit Messages

Commit messages are the story of your project. Every time you run `git commit -m "..."`, you are writing a line in that story. Six months from now, when something is broken and you are scrolling through `git log` trying to figure out what changed and when, you will either thank past-you or curse past-you based on how good these messages are.

Your commit messages are a diary for future-you. I cannot tell you how many times I have searched through old commits to find out when a bug was introduced or why I made a particular decision. A message like "Add email validation to prevent duplicate signups" saves you hours. A message like "fixed stuff" helps no one -- not even you.

### Good vs. Bad: Side by Side

**Good Commit Messages:**

These tell you *what* changed and give you a hint about *why*:

```bash
git commit -m "Add user registration form with email validation"
git commit -m "Fix: Login button not responding on mobile devices"
git commit -m "Refactor: Extract PaymentCard into separate component"
git commit -m "Update: Increase session timeout from 30min to 2hrs"
git commit -m "Remove: Delete unused analytics tracking code"
```

Notice the patterns:
- **Add** -- you built something new
- **Fix** -- you found a bug and squashed it
- **Refactor** -- you reorganized code without changing behavior
- **Update** -- you improved something that already existed
- **Remove** -- you cleaned up something unnecessary

**Bad Commit Messages:**

These tell you absolutely nothing:

```bash
git commit -m "fixed stuff"          # What stuff? Fixed how?
git commit -m "wip"                  # Work in progress... on what?
git commit -m "asdf"                 # You were too lazy to type a message
git commit -m "changes"              # ...thanks?
git commit -m "final version"        # It is never the final version
git commit -m "idk"                  # If you do not know, nobody will
```

Imagine you are moving to a new house and you label every box "stuff." When you get to the new place and need to find your phone charger, you have to open every single box. Now imagine if you had labeled them "Kitchen - utensils and small appliances" and "Bedroom - cables and chargers." That is the difference between good and bad commit messages. You are packing boxes that future-you has to unpack.

### The Simple Formula

If you are not sure what to write, use this formula:

```
[Action]: [What you changed] [Why or context, if needed]
```

Examples:
```bash
git commit -m "Add: Contact form with email and phone fields"
git commit -m "Fix: Prevent crash when user submits empty form"
git commit -m "Update: Switch from PNG to WebP for faster load times"
```

You do not need to write an essay. One clear sentence is perfect. If you need to explain more, you can add a longer description in the body of the commit (after the first line), but for most day-to-day work, a good one-liner is enough.

### Let AI Write Your Messages

When you are working with Claude Code, you can ask it to write commit messages for you. This is actually a great way to learn what good messages look like.

:::tip
Even when AI writes the message, read it before you accept it. Make sure it accurately describes what you did. This is a good habit that helps you stay aware of what each commit contains.
:::

### When to Commit

A common beginner question: "How often should I commit?"

The answer: **commit when you complete a logical unit of work.** Not after every line of code, and not after three days of coding. Here are some good commit points:

- You finished building a component
- You fixed a specific bug
- You added a new feature that works
- You refactored something into a cleaner structure
- You updated configuration or dependencies

A good rule of thumb: if you can describe what you did in one clear sentence, that is a good commit. If you need a paragraph, you probably waited too long and should have committed sooner.

## The .gitignore File

Not everything in your project folder should be tracked by Git. Some files are huge and easily recreated (like `node_modules/`). Some files contain passwords and API keys that would be catastrophic to share publicly. The `.gitignore` file is a simple text file that tells Git: "Pretend these files do not exist."

Every single project you create should have a `.gitignore` file, and it should be one of the very first things you set up -- ideally before your first commit.

Think of `.gitignore` like the bouncer at the door of your Git repository. You give the bouncer a list of names (file patterns) and say "do not let these in." When you run `git add .`, Git checks the list and skips anything that matches. The files still exist on your computer -- they just do not get tracked or uploaded.

### What Should You Ignore?

Here is the standard `.gitignore` for the kind of projects we build in this book (Next.js, Node.js, Supabase):

```gitignore
# Dependencies - huge folder, easily reinstalled with npm install
node_modules/

# Environment variables - CONTAINS YOUR SECRETS
.env
.env.local
.env.development.local
.env.test.local
.env.production.local

# Build output - generated files, not source code
.next/
dist/
out/
build/

# System files - OS junk that nobody needs
.DS_Store
Thumbs.db

# Editor files
.vscode/settings.json
*.swp
*.swo

# Debug logs
npm-debug.log*
yarn-debug.log*
yarn-error.log*

# Turbo cache
.turbo

# Vercel
.vercel
```

### The .env Rule

:::danger[NEVER Commit .env Files]
Your `.env` files contain API keys, database passwords, and other secrets. If you push them to GitHub -- even to a private repository -- consider those secrets **compromised**. Bots scan GitHub constantly looking for accidentally committed credentials.

If you accidentally commit a secret:
1. **Immediately** rotate (change) the key or password
2. Remove the file from Git tracking: `git rm --cached .env`
3. Make sure `.env` is in your `.gitignore`
4. Commit and push the fix

The old secret is still in your Git history, which is why you must rotate it. Deleting the file from the current commit does not erase it from past commits.
:::

This is not hypothetical. Real companies have had major security breaches because someone committed an AWS key to a public repo. It takes automated bots less than a minute to find and exploit leaked credentials.

Before your very first commit on any project, check two things: (1) Is there a `.gitignore` file? (2) Does it include `.env`? Make this a reflex. I actually set up the `.gitignore` before I write a single line of code. It is that important.

### Why Ignore `node_modules/`?

Your `node_modules/` folder can contain hundreds of thousands of files and be hundreds of megabytes. It is entirely recreated when someone runs `npm install`, so there is zero reason to track it in Git. Committing it would make your repository massive, slow to clone, and impossible to review.

### Creating a .gitignore

The simplest way: create the file yourself in your project root.

```bash
# In your project root
touch .gitignore
```

Then paste the template from above. Or even better -- let AI do it.

:::tip
GitHub offers a collection of `.gitignore` templates at [github.com/github/gitignore](https://github.com/github/gitignore). The `Node.gitignore` template is a solid starting point for our projects.
:::

### What If You Already Committed Something You Shouldn't Have?

If you already committed a file and then add it to `.gitignore`, Git will keep tracking it. The `.gitignore` only prevents *new* files from being tracked. To stop tracking a file that is already committed:

```bash
# Stop tracking the file but keep it on your computer
git rm --cached .env

# Now commit the removal
git commit -m "Remove: Stop tracking .env file"
```

The `--cached` flag is important -- it removes the file from Git without deleting it from your computer.

## When Things Go Wrong

You are going to mess up with Git. I mess up with Git. Every developer on the planet has messed up with Git. The good news is that Git is designed to let you recover from almost anything. The data is almost never truly gone -- you just need to know the right command to get it back.

This section is your emergency handbook. Bookmark it.

You know how Ctrl+Z (or Cmd+Z) lets you undo in a document? Git is like that, but way more powerful. Instead of just undoing the last thing you typed, you can undo specific commits from three weeks ago, jump between different versions of your entire project, and even rescue work you thought was deleted. The trick is knowing which "undo" command to use.

### Recovery Command Reference

Here are the most common Git mistakes and exactly how to fix them:

| Situation | Command | What It Does |
|---|---|---|
| Undo last commit, keep changes | `git reset --soft HEAD~1` | Removes the commit but leaves your files staged and ready |
| Undo last commit, unstage changes | `git reset HEAD~1` | Removes the commit and unstages files, but keeps your edits |
| Discard all uncommitted changes | `git checkout -- .` | Resets every modified file back to the last commit. **Destructive -- your edits are gone** |
| Discard changes to one file | `git checkout -- filename.tsx` | Resets just that one file |
| See commit history | `git log --oneline` | Shows a compact list of all commits |
| Stash changes temporarily | `git stash` | Hides your uncommitted work so you can switch branches |
| Bring stashed changes back | `git stash pop` | Restores the most recently stashed work |
| Remove a file from staging | `git reset HEAD filename.tsx` | Unstages a file without losing your changes |
| See what you changed | `git diff` | Shows line-by-line differences in unstaged files |

:::caution
Commands marked as **destructive** permanently erase uncommitted work. If you have not committed your changes, `git checkout -- .` will delete them with no way to recover. Always commit or stash before using destructive commands.
:::

### Common Scenarios

**"I accidentally committed to main instead of a branch"**

This happens all the time. Here is how to fix it:

1. Create a new branch from where you are (this saves your commits):
   ```bash
   git branch feature/my-accidental-work
   ```

2. Reset main back to where it should be:
   ```bash
   git reset --soft HEAD~1
   ```
   Change `1` to however many commits you need to undo.

3. Switch to your new branch:
   ```bash
   git checkout feature/my-accidental-work
   ```

4. Now your commits are safely on the feature branch, and main is back to normal.

**"I need to switch branches but I have uncommitted work"**

Git will not let you switch branches if you have changes that would conflict. Use stash:

```bash
# Save your work temporarily
git stash

# Switch to the other branch
git checkout other-branch

# Do whatever you need to do, then switch back
git checkout your-original-branch

# Bring your work back
git stash pop
```

**"I committed the wrong file"**

If you just committed and realize you included a file you should not have:

```bash
# Undo the commit but keep all changes staged
git reset --soft HEAD~1

# Unstage the file you do not want
git reset HEAD that-wrong-file.txt

# Re-commit without it
git commit -m "Your original commit message"
```

**"I want to see what my code looked like three commits ago"**

```bash
# See the history
git log --oneline

# Temporarily look at an old commit (read-only)
git checkout abc1234

# Go back to where you were
git checkout main
```

### Let AI Be Your Git Paramedic

When you are panicking about a Git mistake, just describe what happened to Claude Code. Seriously. It is one of the best use cases for AI assistance.

Here is a secret that took me years to learn: the scariest thing about Git is not that you will lose your work. It is that Git's error messages are confusing and make you *think* you lost your work. You almost never actually lose anything. If you committed it at some point, Git has it stored somewhere. When in doubt, do not panic, do not start running random commands you found on StackOverflow -- just ask Claude Code to help you recover. Describe what happened plainly, and let it figure out the right commands.

:::tip
The `git reflog` command is your ultimate safety net. It shows every single thing Git has done, even commits you "deleted" with reset. If you truly cannot find something, `git reflog` will help you track it down. Think of it as Git's flight recorder.
:::

## Building User Interfaces with React and Next.js

Alright, this is where things get really fun. Up until now you've been learning foundational stuff -- how the web works, how JavaScript and TypeScript work, how to track your code with Git. All of that matters. But this chapter is where you start *building what people actually see*.

Every app you use on your phone or in your browser -- Instagram, YouTube, Spotify, whatever -- has a **user interface**. That's the buttons, the cards, the menus, the pages, the forms. Everything you tap, scroll, and interact with. And in modern web development, most of that is built with React.

React is a library that lets you build user interfaces by snapping together reusable pieces called **components**. Next.js builds on top of React and adds routing, server-side rendering, and a bunch of powerful features that turn it into a full framework. And Tailwind CSS lets you style everything without ever leaving your HTML.

These three tools -- React, Next.js, and Tailwind -- are the foundation of our frontend stack. They're what companies like Netflix, TikTok, Twitch, and thousands of startups use to build their apps. And once you understand the concepts behind them, you'll be able to describe features to Claude Code and watch them come to life.

By the end of this chapter, you'll understand how modern web apps are actually built -- and you'll be able to tell Claude Code exactly what you want with confidence.

Remember building things with LEGOs? You'd have a baseplate, then snap individual bricks together to make walls, windows, doors -- eventually an entire house. React works the same way. Each LEGO brick is a component. A button is a brick. A navigation bar is a set of bricks snapped together. A whole page is a big collection of bricks. You build complex things by combining simple pieces.

### How to Approach This Chapter

You do **not** need to memorize React syntax. Seriously. That's what Claude Code is for. What you need is to understand the *concepts* -- what components are, how data flows, why state matters, how routing works. When you understand the concepts, you can describe what you want in plain English and Claude Code will write the actual code.

This is different from a traditional coding bootcamp where you'd spend weeks memorizing JSX syntax and React patterns. We're skipping that. Instead, we're going to focus on the ideas -- the mental models -- that let you think clearly about user interfaces. The syntax is just an implementation detail.

When I started learning React, I spent way too long trying to memorize every hook and every pattern. Don't make that mistake. Focus on understanding *what* these things do and *when* you'd use them. The syntax is just details -- and details are easy to look up or generate with AI. The mental model is what matters.

### What You'll Be Able to Do

After this chapter, you'll be able to:

- Look at any web app and mentally break it down into components
- Understand how data flows through a React application
- Know when to use a Server Component vs. a Client Component
- Describe UI features to Claude Code using the right vocabulary
- Review generated React code and know whether it makes sense

That last point is the most important. You're not trying to become a React syntax expert. You're trying to become someone who *understands what good React code looks like* so you can guide the AI and catch mistakes.

### How Long Will This Take?

This chapter has four sections. You can work through them in a single sitting (plan for about **1-2 hours** of reading and video watching), or spread them out over a few days. Either way, don't rush. Let the concepts sink in.

If something doesn't click immediately, that's completely normal -- it'll make more sense once you start building real things. I've seen professional developers take months to fully internalize React's mental model. You have a massive advantage because you're learning it from the start with the right framing.

Let's go -- this is the good stuff.

## What Is a Component?

A component is a reusable piece of user interface. That's it. That's the big idea. Everything you see in a React app -- every button, every card, every navigation bar, every entire page -- is a component.

Think of a LEGO set. You have tiny pieces (a single 2x2 brick), medium pieces (a window frame), and large assemblies (an entire wall). In React, a **button** is a small component. A **user profile card** is a medium component that contains smaller ones (an image, a name, a bio). A **whole page** is a large component that snaps together many medium and small components. You build complex UIs the same way you build complex LEGO structures -- by combining simple, reusable pieces.

### What Does a Component Look Like?

A React component is just a function that returns some HTML-like code. Here's the simplest possible example:

```tsx
function Greeting({ name }: { name: string }) {
  return (
    <div>
      <h1>Hello, {name}!</h1>
      <p>Welcome to our app.</p>
    </div>
  );
}
```

That's a component. It's a function called `Greeting` that takes a `name` and returns some UI. The HTML-looking stuff inside the return is called **JSX** -- it's a syntax that lets you write UI structure right alongside your logic. The curly braces `{name}` let you embed JavaScript values inside the JSX.

You don't need to memorize this syntax. What matters is understanding the concept: **a component is a function that describes a piece of UI.**

### Components Inside Components

Here's where it gets powerful. Components can contain other components. A `ProfilePage` component might contain a `Header` component, a `ProfileCard` component, and a `PostList` component. The `PostList` might contain many `PostCard` components. Each piece is independent and reusable.

This tree-like structure is how every React app is organized. The top of the tree is usually your `App` or page component, and it branches down into smaller and more specific pieces.

### Why Components Matter

Without components, building a web app would mean writing one massive file of tangled HTML, CSS, and JavaScript. Every website built in the early 2000s worked this way, and it was a nightmare to maintain. You'd fix something in one place and accidentally break something in another.

With components, you get:

- **Reusability** -- Build a `Button` once, use it everywhere. Need to change how buttons look across your entire app? Change it in one place.
- **Organization** -- Each piece of UI lives in its own file. Easy to find, easy to fix. When your app grows to dozens of pages, this matters a lot.
- **Isolation** -- If something breaks in the `ProfileCard`, it doesn't affect the `Header`. Each component is its own little world.
- **Testability** -- You can test each component independently to make sure it works correctly.

Here's a rule of thumb I use at work: if a piece of UI shows up in more than one place, it should be a component. And if a component gets longer than about 200-300 lines, it's time to split it into smaller components. Keep things small and focused.

### How You'll Actually Build Components

In practice, you won't be hand-writing components from scratch most of the time. You'll describe what you want to Claude Code, and it will generate the component for you. But because you understand what a component is, you'll be able to review what it gives you and know whether it makes sense.

Notice how the prompt describes *what* the component should show, not *how* to code it. That's the sweet spot. You bring the design thinking ("what should this card contain?"), and Claude Code handles the implementation.

### Real-World Example: Breaking Down a Page

Open any app you use daily -- say, a social media feed. Look at it and try to spot the components:

- The **navigation bar** at the top? That's a component.
- Each **post** in the feed? That's a component, probably containing sub-components for the avatar, the text content, the like button, and the comment section.
- The **sidebar** with suggested follows? That's a component containing a list of smaller **user card** components.
- The **compose box** where you type a new post? Another component.

This is how React developers think. They look at a design and mentally draw boxes around the pieces. Each box is a component. When you start seeing the world this way, you're thinking like a frontend developer.

### The Key Takeaway

Everything in React is a component. Components are functions that return UI. You build complex interfaces by combining simple components. That mental model is the foundation for everything else in this chapter.

## React Core Concepts

Now that you know what components are, let's talk about the three big ideas that make them actually useful: **props**, **state**, and **effects**. These are the core concepts of React. Once you understand these three things, you understand how React apps work.

**Props:** Data passed *into* a component from its parent. Like handing someone a note -- they can read it, but they can't change what you wrote.

**State:** Data that lives *inside* a component and can change over time. When state changes, the component automatically updates on screen.

**useEffect:** A way to run code in response to something happening -- like fetching data when a page loads or updating the document title.

**Components:** The building blocks themselves. Props flow into them, state lives inside them, and effects let them reach out to the world.

### Props: Passing Notes in Class

Imagine you're in class and you write a note that says "Meet at lunch?" and pass it to your friend. Your friend can read the note, but they can't change what you wrote on it. That's exactly how props work in React. A parent component passes data to a child component. The child can use that data to render its UI, but it cannot modify the data it received. If the parent wants to send different data, the parent writes a new note.

In code, it looks like this -- a parent passes `name` and `email` to a `UserCard`:

```tsx
// Parent passes data
<UserCard name="Jordan" email="jordan@email.com" />

// Child receives and displays it
function UserCard({ name, email }) {
  return (
    <div>
      <h2>{name}</h2>
      <p>{email}</p>
    </div>
  );
}
```

The key idea: **data flows down**. Parents pass props to children, never the other way around. This one-way flow makes apps predictable and easy to reason about.

### State: Data That Changes

Props are for data coming *in* from outside. But what about data that changes *inside* a component? That's **state**.

Think of a basketball scoreboard. The score starts at 0-0, but it changes every time someone scores. The scoreboard doesn't get rebuilt from scratch each time -- it just updates the number. React state works the same way. You declare a piece of data that can change (like a score), and whenever it changes, React automatically updates just the part of the screen that needs to reflect the new value.

Here's the classic example -- a counter:

```tsx
import { useState } from "react";

function Counter() {
  const [count, setCount] = useState(0);

  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={() => setCount(count + 1)}>
        Add One
      </button>
    </div>
  );
}
```

`useState(0)` creates a piece of state that starts at `0`. It gives you two things: the current value (`count`) and a function to update it (`setCount`). When the button is clicked, `setCount` updates the value, and React re-renders the component to show the new count.

**The magic of React is this automatic re-rendering.** You never manually update the screen. You update the data, and React figures out what on the screen needs to change.

### useEffect: Reaching Out to the World

Components render UI. But sometimes you need to do things *beyond* rendering -- like fetching data from an API when the page loads, or updating the browser tab title. That's what `useEffect` is for.

Think of useEffect like setting an alarm. You say "when this happens, do that." When the component first appears on screen, fetch some data. When a specific value changes, re-fetch the data. It's a way to connect your component to the outside world -- APIs, timers, the browser itself.

```tsx
import { useState, useEffect } from "react";

function UserProfile({ userId }) {
  const [user, setUser] = useState(null);

  useEffect(() => {
    // This runs when the component appears on screen
    fetch(`/api/users/${userId}`)
      .then(response => response.json())
      .then(data => setUser(data));
  }, [userId]); // Re-run if userId changes

  if (!user) return <p>Loading...</p>;
  return <h1>{user.name}</h1>;
}
```

The `[userId]` at the end is called the **dependency array**. It tells React: "only re-run this effect if `userId` changes." This prevents the effect from running on every single render.

Here's the honest truth: useEffect is the concept that trips up even experienced developers. Don't stress about mastering it right now. When you're working with Claude Code, you can describe what you need ("fetch user data when the page loads") and it will handle the useEffect correctly. Your job is to know that the concept exists and roughly what it does.

### How They All Work Together

Here's the mental model: a React app is a tree of components. Data flows *down* through props. Each component can have its own internal state. And effects let components reach out to the world (APIs, browsers, timers) when things happen.

That's it. Props in, state inside, effects outward. Everything else in React is built on these three ideas.

## Next.js: The Full Picture

React is great at building components, but it doesn't have opinions about how to organize your pages, handle navigation, or talk to a server. That's where **Next.js** comes in. It takes React and wraps it in a full framework that handles routing, server-side rendering, API endpoints, and a lot more.

If React is the engine, Next.js is the whole car.

React is like having a really great stove. You can cook amazing things on it. But a stove alone isn't a restaurant. You still need a dining room, a menu, a front door, and a way for customers to find you. Next.js is the whole restaurant -- it gives you the stove (React) plus everything else you need to actually serve people: pages they can navigate to, a server that sends the right content, and a structure that keeps everything organized.

### File-Based Routing

One of the most intuitive things about Next.js is how routing works. In a lot of frameworks, you have to write code to define your routes (URLs). In Next.js, **the file structure IS the routing**. If you create a file, you've created a page.

Here's how the `app/` folder maps to URLs:

```
app/
  page.tsx           -->  yoursite.com/
  about/
    page.tsx         -->  yoursite.com/about
  blog/
    page.tsx         -->  yoursite.com/blog
    [slug]/
      page.tsx       -->  yoursite.com/blog/any-post-name
  dashboard/
    page.tsx         -->  yoursite.com/dashboard
    settings/
      page.tsx       -->  yoursite.com/dashboard/settings
```

See the pattern? Every folder becomes a URL segment, and every `page.tsx` file inside that folder becomes the page for that URL. The `[slug]` part with square brackets is a **dynamic route** -- it matches any value, so `yoursite.com/blog/my-first-post` and `yoursite.com/blog/react-is-cool` both go to the same page component, which receives the slug as a parameter.

No route configuration files. No routing library to install. Just folders and files. This is one of those things that feels almost too simple, but it's genuinely how it works.

### Server Components vs. Client Components

This is a concept that's unique to modern Next.js, and it's worth understanding even if you don't write the code yourself.

By default, every component in Next.js is a **Server Component**. That means it runs on the server, not in the user's browser. The server does the work, generates the HTML, and sends the finished result to the browser. This is great for performance -- the browser gets a ready-to-display page instead of a blank screen that has to load JavaScript first.

But some things *need* to happen in the browser -- like responding to button clicks, tracking what a user types into an input, or showing/hiding a dropdown. For those, you use a **Client Component** by adding `"use client"` at the top of the file.

- **Server Components (default):** Run on the server. Great for fetching data, reading from a database, and rendering content. Faster for the user because less JavaScript is sent to the browser.
- **Client Components:** Run in the browser. Needed for interactivity: clicks, typing, hover effects, animations, and anything that uses useState or useEffect.

The rule is simple: **start with Server Components (the default) and only add "use client" when you need interactivity.** Most of your pages will be Server Components that contain a few Client Components for the interactive parts.

This is a rule I follow every single day at work: always default to Server Components. Only add "use client" when you actually need hooks like useState or useEffect, or when you need event handlers like onClick. If you can render it on the server, do it on the server. It's faster for your users and simpler to reason about. When you're prompting Claude Code, you can even say "make this a server component" and it'll know what you mean.

### Creating a Next.js Project

When you're ready to start a project, this is the prompt to give Claude Code:

"Create a new Next.js app with TypeScript and Tailwind CSS. Use the App Router. Set it up in a folder called my-app."

That one prompt sets up an entire project with the right configuration. You'll get a working app you can run with `npm run dev` and view in your browser at `http://localhost:3000`.

### What You Need to Remember

You don't need to memorize the Next.js API. Here's what actually matters:

1. **File-based routing** -- folders and files determine your URLs. No configuration needed.
2. **Server Components are the default** -- they run on the server and are great for performance.
3. **Client Components are for interactivity** -- add `"use client"` only when you need it.
4. **Next.js gives you the full package** -- routing, server rendering, API routes, and more, all in one framework.

When you're building with Claude Code, these concepts help you ask the right questions and make the right decisions. "Should this be a server component or client component?" is a question you'll ask yourself often, and now you know the answer.

## Styling with Tailwind CSS

Alright, your app works. Components render, data flows, pages route. But it looks... plain. Time to make it look good. That's where **Tailwind CSS** comes in.

Tailwind is a utility-first CSS framework. Instead of writing CSS in separate files with class names you invent, you apply small, single-purpose classes directly to your HTML elements. Each class does exactly one thing, and you combine them to build any design you want.

Traditional CSS is like buying pre-built furniture from a catalog. You get a "card style" or a "button style" and it comes with a bunch of opinions about how it should look. Tailwind is like having a massive bin of individual building blocks -- one block sets the color, another sets the padding, another rounds the corners, another adds a shadow. You snap together exactly the blocks you need to build exactly the thing you want. Nothing extra, nothing wasted.

### What Tailwind Looks Like

Here's a single styled button to show you the idea:

```tsx
<button className="bg-blue-500 text-white px-4 py-2 rounded-lg hover:bg-blue-600 transition">
  Click Me
</button>
```

Each class does one thing:
- `bg-blue-500` -- sets the background to a medium blue
- `text-white` -- makes the text white
- `px-4` -- adds horizontal padding
- `py-2` -- adds vertical padding
- `rounded-lg` -- rounds the corners
- `hover:bg-blue-600` -- darkens the blue when you hover over it
- `transition` -- makes the color change smooth

That's it. No separate CSS file. No inventing class names. No switching between files. The styling lives right next to the element it applies to.

### Why Tailwind Works So Well with AI

Here's the real reason I love Tailwind for what we're doing: **it's incredibly easy to describe in plain English.** When you tell Claude Code what you want something to look like, Tailwind's utility classes map almost perfectly to natural language descriptions.

You say "rounded corners" -- it adds `rounded-lg`. You say "shadow on hover" -- it adds `hover:shadow-lg`. You say "blue background with white text" -- it adds `bg-blue-500 text-white`. The translation from your words to code is nearly one-to-one.

Notice how the prompt doesn't mention any CSS classes. You just describe what you want it to *look like*, and Claude Code picks the right Tailwind utilities. This is why understanding concepts matters more than memorizing syntax.

You absolutely do not need to memorize Tailwind classes. I've been using Tailwind for years and I still look things up on their docs site (tailwindcss.com/docs). The docs have a search bar and every class is listed with visual examples. But honestly? Most of the time I just describe what I want to Claude Code and it picks the right classes. That's the whole point of this approach.

### The Mindset Shift

If you've ever written traditional CSS, Tailwind feels weird at first. "Why is there so much stuff in my HTML?" is a normal reaction. But once you try it, two things happen:

1. **You stop context-switching.** No more jumping between HTML and CSS files. Everything you need is right there.
2. **You stop inventing names.** No more agonizing over whether to call it `.card-wrapper` or `.card-container` or `.card-outer`. You just apply the utilities directly.

And with Claude Code doing most of the heavy lifting, you get to focus on the fun part: deciding what things should look like.

### Responsive Design

Tailwind makes responsive design (making things look good on phones, tablets, and desktops) surprisingly simple. You prefix classes with a screen size:

```tsx
<div className="flex flex-col md:flex-row gap-4">
  <div className="w-full md:w-1/2">Left side</div>
  <div className="w-full md:w-1/2">Right side</div>
</div>
```

On mobile, the two divs stack vertically (`flex-col`, each `w-full`). On medium screens and up (`md:`), they sit side by side (`flex-row`, each `w-1/2`). One line of classes handles the whole layout shift.

When prompting Claude Code, just say "make it responsive" or "stack on mobile, side by side on desktop" and it knows exactly what to do.

### What You Need to Remember

1. **Tailwind = utility classes applied directly to elements.** No separate CSS files for most things.
2. **Each class does one thing.** You combine them to build any design.
3. **You don't need to memorize classes.** Describe what you want to Claude Code in plain English.
4. **Responsive design uses prefixes** like `md:` and `lg:` to change styles at different screen sizes.
5. **The Tailwind docs (tailwindcss.com/docs) are excellent** if you ever want to look something up yourself.

## Databases & Supabase

Every app you have built so far loses its data the moment you refresh the page. That is about to change. In this chapter, you are going to learn how to store data permanently in a real database -- and Supabase is going to make it surprisingly easy.

Supabase is your backend-in-a-box. It gives you a PostgreSQL database, user authentication, file storage, and real-time subscriptions. Instead of spending weeks setting up servers and databases from scratch, you get all of it with a few clicks and a free account.

Building a backend from scratch is like building a house. You need to pour the foundation, frame the walls, run the plumbing, wire the electricity -- all before you can even move in. Supabase is like renting a furnished apartment. The structure is there, the utilities work, and you can start living in it on day one. You still need to arrange the furniture (your data tables) the way you want, but the hard stuff is handled.

### What You Will Learn

- **Database Fundamentals** -- What tables, rows, and columns are -- and the SQL basics you need to talk to a database.
- **Supabase Setup** -- Create a project, get your API keys, and connect it to your Next.js app.
- **Migrations** -- The professional way to track changes to your database structure over time.
- **Using Supabase in Code** -- Fetch, create, update, and delete data from your app using the Supabase client.
- **Row Level Security** -- Protect your data so users can only see and change what belongs to them.

Databases are one of the most important skills in all of software development. Almost every app you will ever build -- whether it is a to-do list, a social media platform, or a billion-dollar business -- has a database at its core. The concepts you learn in this chapter will follow you for your entire career. Take your time with this one.

Let's get into it.

## Database Fundamentals

A database is where your app's data lives permanently. When a user creates an account, writes a post, or saves their settings -- all of that goes into a database. Without one, your app has amnesia. It forgets everything the second someone closes the browser.

### What Is a Database?

You have used Google Sheets before. A database is the same basic idea -- data organized into rows and columns -- but built to handle millions of rows, multiple users reading and writing at the same time, and rules that keep the data clean and consistent. Think of it as a spreadsheet that went to the gym and got a computer science degree.

A PostgreSQL database (the kind Supabase gives you) is organized into three things:

- **Tables** are like individual sheets in a spreadsheet. You might have a `users` table, a `posts` table, and a `comments` table.
- **Rows** are like spreadsheet rows. Each row is one record -- one user, one post, one comment.
- **Columns** are like spreadsheet columns. Each column is one piece of information -- a name, an email, a timestamp.

### SQL: Talking to Your Database

SQL (Structured Query Language) is the language you use to communicate with a database. It has been around since the 1970s and it is not going anywhere. Here are the four essential operations, known as **CRUD**:

**Create (INSERT)**

```sql
INSERT INTO users (name, email)
VALUES ('Marcus', 'marcus@email.com');
```

This adds a new row to the `users` table.

**Read (SELECT)**

```sql
SELECT * FROM users WHERE email = 'marcus@email.com';
```

This asks the database to find and return every column for the user with that email.

**Update (UPDATE)**

```sql
UPDATE users SET name = 'Marcus Jr.' WHERE email = 'marcus@email.com';
```

This changes the name for a specific user.

**Delete (DELETE)**

```sql
DELETE FROM users WHERE email = 'marcus@email.com';
```

This removes a row. In real-world applications, we usually do "soft deletes" instead -- marking a row as deleted without actually removing it -- so we can undo mistakes. More on that later.

You do not need to memorize SQL right now. When you are vibe coding, Claude Code will write the SQL for you. But you need to *understand* what it is doing. If Claude generates a `SELECT` query, you should know it is reading data. If it generates an `INSERT`, you should know it is creating data. That understanding is what lets you catch mistakes before they hit production.

### Creating a Table

Here is what it looks like to create a table from scratch:

```sql
CREATE TABLE users (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  name TEXT NOT NULL,
  email TEXT UNIQUE NOT NULL,
  created_at TIMESTAMPTZ DEFAULT now()
);
```

Let's break that down:

- `id UUID PRIMARY KEY` -- Every row gets a unique identifier. Think of it like a social security number for that row.
- `DEFAULT gen_random_uuid()` -- The database generates the ID automatically.
- `TEXT NOT NULL` -- This column holds text and cannot be left empty.
- `UNIQUE` -- No two rows can have the same value in this column.
- `TIMESTAMPTZ DEFAULT now()` -- Automatically records when the row was created.

## Setting Up Supabase

Time to set up your first real backend. Supabase gives you a full PostgreSQL database, authentication, and more -- all from a free account. By the end of this section, your Next.js app will be connected to a real database.

### Create Your Supabase Project

1. **Sign up at [supabase.com](https://supabase.com).** Create a free account. You can sign in with GitHub, which makes life easier.

2. **Create a new project.** Click "New Project." Choose a name for it (something like `my-first-app`). Set a strong database password -- write it down somewhere safe, you will need it later. Pick a region close to where you live for faster performance.

3. **Wait for it to spin up.** Supabase takes about a minute to create your project. Grab a snack.

4. **Copy your API credentials.** Once your project is ready, go to **Settings > API**. You need two values:
   - **Project URL** -- looks like `https://abcdefghij.supabase.co`
   - **Anon key** -- a long string of characters

5. **Add credentials to your project.** In your Next.js project, create a file called `.env.local` in the root folder:

   ```bash
   NEXT_PUBLIC_SUPABASE_URL=https://your-project.supabase.co
   NEXT_PUBLIC_SUPABASE_ANON_KEY=your-anon-key-here
   ```

6. **Install the Supabase client library.**

   ```bash
   npm install @supabase/supabase-js
   ```

That is it. Your project now has a real database behind it.

The `.env.local` file is where you store secrets -- API keys, passwords, configuration that should never be pushed to GitHub. Your `.gitignore` file should already exclude it. If it does not, add `.env.local` to your `.gitignore` immediately. Leaking API keys on GitHub is one of the most common beginner mistakes, and it can cost real money if someone finds them.

### Understanding the Anon Key

The anon key is not exactly a secret -- it is designed to be used in the browser. But it is not a free pass either. By itself, the anon key gives very limited access to your database. The real security comes from **Row Level Security (RLS)**, which we will set up later in this chapter. Think of the anon key as your front door key -- it gets you into the building, but each apartment still has its own lock.

### The Supabase Dashboard

Take a few minutes to explore the Supabase dashboard. Here are the tabs you will use most:

- **Table Editor** -- A visual spreadsheet-like view of your data. Great for poking around.
- **SQL Editor** -- Write and run SQL queries directly. Very useful for testing.
- **Authentication** -- Manage users, sign-up settings, and login providers.
- **Settings > API** -- Where your keys live.

## Database Migrations

You could create tables by clicking around in the Supabase dashboard. It works. But professionals do not do it that way -- and for good reason.

Imagine you build your whole database by clicking buttons in the dashboard. Everything works great on your laptop. Now you need to set up the exact same database for production. Can you remember every table, every column, every rule you created? Probably not. That is the problem migrations solve.

### What Is a Migration?

When someone builds a house, they do not just start nailing boards together. They draw up blueprints, file them with the city, and follow them step by step. If they want to add a room later, they file a new blueprint -- they do not erase the original plans and redraw them. Database migrations work the same way. Each migration is a blueprint that describes one change to your database. They are filed in order, tracked in Git, and can be replayed on any machine to recreate the exact same database.

A migration is a SQL file that describes a specific change to your database structure. "Create the users table." "Add a profile_picture column." "Create the posts table." Each change gets its own file with a timestamp, and they run in order.

### Setting Up the Supabase CLI

Before you can create migrations, you need the Supabase command-line tool:

1. **Install the Supabase CLI.**

   ```bash
   npm install -g supabase
   ```

2. **Log in to Supabase.**

   ```bash
   supabase login
   ```

3. **Initialize Supabase in your project.**

   ```bash
   supabase init
   ```

   This creates a `supabase/` folder in your project. That folder is where all your migration files will live.

4. **Link to your remote project.**

   ```bash
   supabase link --project-ref your-project-ref
   ```

   You can find your project ref in the Supabase dashboard under **Settings > General**.

### The Migration Workflow

Once you are set up, creating and running migrations follows a consistent pattern:

1. **Think about the change you need.** "I need a table to store blog posts."

2. **Create a migration file.**

   ```bash
   supabase migration new create_posts_table
   ```

   This creates a file like `supabase/migrations/20260224120000_create_posts_table.sql`. The number at the beginning is a timestamp that keeps migrations in order.

3. **Write your SQL in the migration file.**

   ```sql
   -- supabase/migrations/20260224120000_create_posts_table.sql
   CREATE TABLE public.posts (
     id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
     title TEXT NOT NULL,
     body TEXT,
     author_id UUID REFERENCES public.users(id),
     created_at TIMESTAMPTZ DEFAULT now(),
     updated_at TIMESTAMPTZ DEFAULT now()
   );

   ALTER TABLE public.posts ENABLE ROW LEVEL SECURITY;
   ```

4. **Test it locally.**

   ```bash
   supabase db push
   ```

5. **Commit the migration file to Git.** This is critical. Migration files go in your repo so every developer and every environment can reproduce the same database.

6. **Deploy to production.**

   ```bash
   supabase db push --linked
   ```

### The Golden Rule

Never, ever edit a migration file that has already been applied to production. If you need to change something, create a new migration. Migrations are an append-only history of your database. Editing old ones is like going back and rewriting the blueprints after the building is already standing -- it causes confusion and breaks things. If you made a mistake, the fix is always "write a new migration that corrects it."

### Checking Migration Status

You can always see which migrations have been applied:

```bash
supabase migration list
```

This shows you a list of all migration files and whether they have been run on your local and remote databases.

### Why This Matters

Migrations might feel like extra work right now. But they solve real problems:

- **Reproducibility** -- Any developer can clone your repo and get the exact same database by running the migrations.
- **History** -- You have a complete record of every change your database has ever been through.
- **Safety** -- Changes are reviewed in pull requests before they hit production, just like code.
- **Rollbacks** -- If something goes wrong, you know exactly what changed and when.

## Using Supabase in Code

Now for the fun part. You have a database. You have tables. It is time to actually talk to your database from your app. The Supabase client library makes this straightforward -- you ask for data, and it gives you back data or an error. That is the pattern.

### Setting Up the Client

First, you need a utility file that creates and exports a Supabase client. This is the file you will import everywhere:

```typescript
// lib/supabase.ts
import { createClient } from '@supabase/supabase-js';

const supabase = createClient(
  process.env.NEXT_PUBLIC_SUPABASE_URL!,
  process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!
);

export default supabase;
```

That `!` after each environment variable is TypeScript saying "trust me, this value exists." It will because you set them up in `.env.local` earlier.

### The Pattern: Data or Error

Every Supabase query returns the same shape:

```typescript
const { data, error } = await supabase.from('posts').select('*');
```

You always get two things back: `data` (what you asked for) and `error` (what went wrong, if anything). Always check for errors. Always.

- **data:** The result of your query. Could be an array of rows, a single row, or null if nothing was found.
- **error:** If something went wrong, this tells you what happened. If everything is fine, this is null.

### Reading Data (SELECT)

Fetch all posts, newest first:

```typescript
const { data: posts, error } = await supabase
  .from('posts')
  .select('*')
  .order('created_at', { ascending: false });

if (error) {
  console.error('Failed to fetch posts:', error.message);
  return;
}

// posts is now an array of post objects
```

Fetch a single post by ID:

```typescript
const { data: post, error } = await supabase
  .from('posts')
  .select('*')
  .eq('id', postId)
  .single();
```

The `.eq()` method means "where this column equals this value." The `.single()` method says "I expect exactly one result, give me an object instead of an array."

### Creating Data (INSERT)

```typescript
const { data: newPost, error } = await supabase
  .from('posts')
  .insert({
    title: 'My First Post',
    body: 'Hello, world!',
    author_id: userId,
  })
  .select()
  .single();
```

The `.select()` after `.insert()` tells Supabase to return the newly created row. Without it, you just get confirmation that the insert worked but no data back.

### Updating Data (UPDATE)

```typescript
const { error } = await supabase
  .from('posts')
  .update({ title: 'My Updated Post' })
  .eq('id', postId);
```

Always include a `.eq()` (or another filter) so you do not accidentally update every row in the table. That would be bad.

### Deleting Data (DELETE)

```typescript
const { error } = await supabase
  .from('posts')
  .update({ deleted_at: new Date().toISOString() })
  .eq('id', postId);
```

Notice we are not actually deleting the row. We are setting a `deleted_at` timestamp. This is called a "soft delete." The data is still in the database, but your app treats it as gone. This means you can always undo a delete, you have a record of when it was deleted, and you never accidentally lose data. In professional development, hard deletes are almost never the right call. Always soft delete.

### Filtering Data

Supabase has a rich set of filters beyond `.eq()`:

```typescript
// Posts from the last 7 days
const { data } = await supabase
  .from('posts')
  .select('*')
  .gte('created_at', sevenDaysAgo)
  .is('deleted_at', null);

// Posts where title contains a search term
const { data } = await supabase
  .from('posts')
  .select('*')
  .ilike('title', `%${searchTerm}%`);
```

- `.gte()` -- greater than or equal to
- `.is()` -- checks for null
- `.ilike()` -- case-insensitive pattern matching

## Row Level Security

This is the single most important security concept in Supabase. Without Row Level Security, anyone who has your anon key (which is exposed in the browser) could read, modify, or delete every row in your database. With RLS, you control exactly who can see and change each row.

### What Is RLS?

Imagine a nightclub where every guest's belongings are stored in personal lockers. Without a bouncer, anyone who walks in the door can open any locker and take whatever they want. Row Level Security is the bouncer. It checks every person at the door and says: "You can open your locker. You cannot touch anyone else's." Even if someone sneaks through the front door (gets your API key), the bouncer still stops them from accessing data that is not theirs.

RLS works at the database level. It is not something your app code can bypass or forget to check. Every single query that hits your database gets filtered through your RLS policies before any data is returned. That is what makes it so powerful.

### Enabling RLS

RLS is a two-step process: turn it on, then write policies that define the rules.

**Step 1: Enable RLS on a Table**

```sql
ALTER TABLE public.posts ENABLE ROW LEVEL SECURITY;
```

Once you enable RLS, the default behavior is **deny everything**. No one can read, write, or delete any rows until you create policies that allow it. This is secure by default, which is exactly what you want.

**Step 2: Create Policies**

A policy is a rule that says "this type of user can perform this action on rows that match this condition."

**Users can read their own posts:**

```sql
CREATE POLICY "Users can view their own posts"
  ON public.posts
  FOR SELECT
  USING (auth.uid() = author_id);
```

**Users can create posts (as themselves):**

```sql
CREATE POLICY "Users can create their own posts"
  ON public.posts
  FOR INSERT
  WITH CHECK (auth.uid() = author_id);
```

**Users can update their own posts:**

```sql
CREATE POLICY "Users can update their own posts"
  ON public.posts
  FOR UPDATE
  USING (auth.uid() = author_id)
  WITH CHECK (auth.uid() = author_id);
```

Let's break down the key parts:

- `auth.uid()` -- Supabase automatically knows who is making the request based on their login session. This returns their user ID.
- `USING (...)` -- "Only return rows where this condition is true." This filters what you can read.
- `WITH CHECK (...)` -- "Only allow the write if this condition is true." This validates what you can create or change.

### A Common Pattern: Public Read, Private Write

Many apps want everyone to be able to read data, but only the owner can edit it:

```sql
-- Anyone can read posts
CREATE POLICY "Posts are publicly readable"
  ON public.posts
  FOR SELECT
  USING (true);

-- Only the author can update their own posts
CREATE POLICY "Authors can update their posts"
  ON public.posts
  FOR UPDATE
  USING (auth.uid() = author_id);
```

`USING (true)` means "this condition is always true" -- so everyone gets access for that operation.

Here is the rule that will save you from a nightmare: enable RLS on every single table, every single time. No exceptions. Even if the table seems harmless. Even if you think "nobody would ever query this directly." If RLS is not on, your data is exposed. I have seen production apps get their entire database scraped because one developer forgot to enable RLS on a "temporary" table. Do not be that developer.

### Testing Your Policies

The Supabase dashboard has an "RLS Debugger" in the SQL Editor that lets you test your policies. You can simulate queries as different users to make sure the right people see the right data. Use it. Do not just assume your policies work -- verify them.

### Chapter 6 Recap

- Databases store your app's data in tables with rows and columns
- SQL (SELECT, INSERT, UPDATE, DELETE) is how you talk to a database
- Supabase gives you a PostgreSQL database, auth, and storage out of the box
- Migrations are version-controlled blueprints for database changes
- The Supabase client returns { data, error } -- always check both
- Row Level Security protects your data at the database level -- enable it on every table

## APIs with Hono

In the last chapter, you learned how to store and retrieve data with Supabase. But right now, your frontend talks to Supabase directly. That works for simple apps, but as things get more complex, you need a layer in between -- a place where you can add business logic, validate data, and control what the outside world can access. That layer is called an API, and Hono is what we are going to build it with.

Think about a fast-food restaurant. You do not walk into the kitchen and start cooking your own food. You pull up to the drive-through window, place your order (a request), and someone hands you a bag of food (a response). The drive-through window is the API. It is a controlled interface between the outside world (you in your car) and the internal operations (the kitchen). The customer does not need to know how the kitchen works. The kitchen does not need to know anything about the customer. The window handles the handoff.

### Why Hono?

Next.js has its own API routes, and you will use those too. But Hono is a dedicated API framework -- small, fast, and designed specifically for building HTTP services. It runs on edge platforms like Cloudflare Workers, which means your API can be deployed close to your users all around the world. It is also excellent for learning because it is minimal and straightforward.

### What You Will Learn

- **Getting Started** -- Create a Hono project and run your first API server.
- **Routes** -- Define endpoints that handle GET, POST, PUT, and DELETE requests.
- **Middleware** -- Add logging, security, and authentication that runs before your route logic.

APIs are what make modern software work. When your weather app shows the forecast, it is calling a weather API. When you log in with Google, that is an authentication API. When you pay for something online, that is a payment API. Learning to build APIs is learning to build the plumbing that connects everything together. It is one of the most marketable skills in software development.

Let's build something.

## Getting Started with Hono

Hono (the Japanese word for "flame") is a small, fast web framework for building APIs. It handles the boring parts -- parsing requests, routing URLs to the right code, sending responses -- so you can focus on the interesting parts, like what your API actually does.

### What Is an API Framework?

When a request comes into your server, a lot needs to happen: figure out what URL was requested, check what HTTP method was used (GET, POST, etc.), parse the body if there is one, run some logic, and send back a response with the right status code. You could write all of that from scratch, but that is like building your own car engine when you just want to drive to the store.

An API framework gives you the engine. You just tell it where to go.

### Create Your First Hono Project

1. **Generate the project.**

   ```bash
   npm create hono@latest my-api
   ```

   When prompted, choose the **Cloudflare Workers** or **Node.js** template. Either works fine for learning.

2. **Navigate into the project and install dependencies.**

   ```bash
   cd my-api
   npm install
   ```

3. **Start the development server.**

   ```bash
   npm run dev
   ```

   Your API is now running at `http://localhost:8787` (or `3000` depending on your template). Open that URL in your browser and you should see a response.

4. **Open the project in your editor.**

   Look at the main file (usually `src/index.ts`). You will see something like this:

   ```typescript
   import { Hono } from 'hono';

   const app = new Hono();

   app.get('/', (c) => {
     return c.text('Hello Hono!');
   });

   export default app;
   ```

   That is your entire API. Three lines of actual code. Let's break it down.

### Understanding the Basics

```typescript
const app = new Hono();
```

This creates your application. Think of it as starting up the kitchen in our drive-through analogy.

```typescript
app.get('/', (c) => {
  return c.text('Hello Hono!');
});
```

This says: "When someone makes a GET request to the root URL (`/`), run this function and send back the text 'Hello Hono!'"

The `c` parameter is the **context**. It contains everything about the request (what the client asked for) and provides methods to build the response (what you send back). You will use `c` constantly:

- `c.text('...')` -- Send a plain text response
- `c.json({ ... })` -- Send a JSON response (this is the one you will use most)
- `c.req` -- Access details about the incoming request
- `c.req.param('id')` -- Get a URL parameter
- `c.req.json()` -- Parse the request body as JSON

Here is something I wish someone had told me earlier: when you are building an API, your "users" are not people staring at a screen. Your users are other programs -- frontends, mobile apps, other APIs. They send structured requests and expect structured responses. That is why almost everything in API-land is JSON. Machines talking to machines, in a format both sides understand.

### Testing Your API

You do not need a frontend to test an API. Open a new terminal (keep your server running) and use `curl`:

```bash
curl http://localhost:8787/
```

You should see `Hello Hono!` printed in your terminal. You just made an HTTP request and got a response, using nothing but the command line.

You can also use the browser for GET requests -- just type the URL into the address bar. For POST, PUT, and DELETE requests, you will need `curl` or a tool like [Hoppscotch](https://hoppscotch.io/) or [Postman](https://www.postman.com/).

## Basic Routes

Routes are the core of any API. Each route is a combination of an HTTP method (GET, POST, PUT, DELETE) and a URL path. When a request comes in, Hono checks: "Does the method and path match any route I know about?" If yes, it runs that route's handler function. If no, it returns a 404.

### What Are Routes?

Think about a postal service. Every letter has an address that tells the mail carrier exactly where to deliver it. API routes work the same way. A request to `GET /api/tasks` is like a letter addressed to "the tasks department, read-only window." A request to `POST /api/tasks` goes to the same department but through the "new submissions" window. The address (URL path) tells the API where to go. The method (GET, POST, etc.) tells it what to do when it gets there.

### The Four HTTP Methods You Need

These map directly to the CRUD operations you learned with databases:

| Method   | Purpose        | Database Equivalent |
|----------|---------------|-------------------|
| `GET`    | Read data      | SELECT            |
| `POST`   | Create data    | INSERT            |
| `PUT`    | Update data    | UPDATE            |
| `DELETE` | Delete data    | DELETE (soft)     |

### Building CRUD Routes

Here is a complete set of routes for managing tasks:

**GET -- Fetch All Tasks**

```typescript
app.get('/api/tasks', async (c) => {
  const tasks = await getAllTasks();
  return c.json(tasks);
});
```

This returns an array of all tasks as JSON.

**GET -- Fetch a Single Task**

```typescript
app.get('/api/tasks/:id', async (c) => {
  const id = c.req.param('id');
  const task = await getTaskById(id);

  if (!task) {
    return c.json({ error: 'Task not found' }, 404);
  }

  return c.json(task);
});
```

The `:id` in the path is a **URL parameter**. When someone requests `/api/tasks/abc-123`, the value `abc-123` is available through `c.req.param('id')`. If the task does not exist, we return a 404 status code.

**POST -- Create a Task**

```typescript
app.post('/api/tasks', async (c) => {
  const body = await c.req.json();
  const newTask = await createTask(body);
  return c.json(newTask, 201);
});
```

The `201` status code means "Created." It tells the client that the request succeeded and a new resource was created.

**PUT -- Update a Task**

```typescript
app.put('/api/tasks/:id', async (c) => {
  const id = c.req.param('id');
  const body = await c.req.json();
  const updated = await updateTask(id, body);

  if (!updated) {
    return c.json({ error: 'Task not found' }, 404);
  }

  return c.json(updated);
});
```

**DELETE -- Soft Delete a Task**

```typescript
app.delete('/api/tasks/:id', async (c) => {
  const id = c.req.param('id');
  await softDeleteTask(id);
  return c.json({ success: true });
});
```

Notice the function is called `softDeleteTask`, not `deleteTask`. As we discussed in the database chapter, professional applications almost never hard-delete data. The function behind this route should be setting a `deleted_at` timestamp, not actually removing the row. Name things honestly so future-you (or anyone reading your code) knows exactly what is happening.

Five routes total. That is a full CRUD API. Every resource in your application -- users, posts, comments, tasks -- follows this same pattern.

### Status Codes That Matter

You do not need to memorize all HTTP status codes. Here are the ones you will use 90% of the time:

| Code | Meaning               | When to Use                    |
|------|-----------------------|-------------------------------|
| 200  | OK                    | Successful GET, PUT            |
| 201  | Created               | Successful POST                |
| 400  | Bad Request           | Client sent invalid data       |
| 401  | Unauthorized          | Not logged in                  |
| 403  | Forbidden             | Logged in but not allowed      |
| 404  | Not Found             | Resource does not exist         |
| 500  | Internal Server Error | Something broke on the server  |

## Middleware

So far, every request that hits your API goes straight to the route handler. But in real applications, you almost always need to do something *before* the route logic runs. Check if the user is logged in. Log the request for debugging. Make sure the request is coming from an allowed website. That is what middleware does.

### What Is Middleware?

Before you board a plane, you go through security. They check your ID, scan your bags, and make sure you are not carrying anything dangerous. If everything checks out, you proceed to your gate. If something is wrong, you get stopped right there -- you never make it to the plane. Middleware works exactly the same way. Every request passes through your middleware before it reaches the route handler. The middleware can inspect the request, modify it, let it through, or reject it entirely.

Middleware is a function that runs between the incoming request and your route handler. It can:

- **Inspect** the request (check headers, validate tokens)
- **Modify** the request (add user info for downstream handlers)
- **Short-circuit** the request (return a 401 before the route ever runs)
- **Run after** the route (log how long the response took)

### Built-In Middleware

Hono ships with several middleware functions that handle common needs. You do not have to build these yourself.

**Logger**

Prints every request to your terminal. Invaluable for debugging.

```typescript
import { logger } from 'hono/logger';

app.use('*', logger());
```

Now every request shows up in your console:

```
  --> GET /api/tasks 200 12ms
  --> POST /api/tasks 201 45ms
  --> GET /api/tasks/bad-id 404 3ms
```

**CORS**

CORS (Cross-Origin Resource Sharing) controls which websites can call your API. Without it, a browser will block requests from a different domain.

```typescript
import { cors } from 'hono/cors';

app.use('*', cors());
```

By default, this allows requests from anywhere. In production, you will want to restrict it:

```typescript
app.use('*', cors({
  origin: 'https://my-frontend.com',
}));
```

CORS errors are one of the most common headaches for beginners. You build your frontend, build your API, and then nothing works because the browser blocks the request. The fix is almost always adding CORS middleware to your API. When you see "has been blocked by CORS policy" in the browser console, come back to this section.

### Custom Middleware

The built-in middleware covers common cases, but you will also need your own. The most common custom middleware is authentication.

**Authentication Middleware**

```typescript
const authMiddleware = async (c, next) => {
  const token = c.req.header('Authorization');

  if (!token) {
    return c.json({ error: 'Unauthorized' }, 401);
  }

  // Validate the token (check with your auth provider)
  const user = await validateToken(token);

  if (!user) {
    return c.json({ error: 'Invalid token' }, 401);
  }

  // Attach user info so route handlers can use it
  c.set('user', user);

  // Continue to the route handler
  await next();
};
```

The key part is `await next()`. This tells Hono: "Everything checks out, continue to the next middleware or route handler." If you never call `next()`, the request stops at your middleware.

### Applying Middleware

You have two choices for where middleware runs:

**On Every Route**

```typescript
app.use('*', logger());
app.use('*', cors());
```

The `'*'` means "match all routes." Logger and CORS usually go here.

**On Specific Routes**

```typescript
app.use('/api/admin/*', authMiddleware);
```

This applies the auth middleware only to routes that start with `/api/admin/`. Public routes like `GET /api/posts` skip it entirely.

This pattern is powerful. You can layer middleware however you need:

```typescript
// These run on every request
app.use('*', logger());
app.use('*', cors());

// These only run on protected routes
app.use('/api/admin/*', authMiddleware);
app.use('/api/admin/*', requireAdminRole);
```

### The Middleware Chain

When a request comes in, middleware runs in the order you defined it. Think of it as a pipeline:

1. Logger middleware logs the request
2. CORS middleware checks the origin
3. Auth middleware validates the token
4. **Your route handler runs**
5. The response travels back through the middleware in reverse

This "onion" pattern means middleware can do things both before *and* after the route handler. The logger, for example, records the start time before the route runs and calculates the duration after it finishes.

The order of your middleware matters. If you put your auth middleware before the CORS middleware, a browser might get a CORS error instead of a proper 401 response -- which is confusing to debug. As a rule of thumb: logger first, then CORS, then authentication, then your routes. That order handles 95% of cases.

### Chapter 7 Recap

- Hono is a small, fast framework for building HTTP APIs
- Routes combine an HTTP method (GET, POST, PUT, DELETE) with a URL path
- The context object (c) gives you access to the request and tools to build a response
- CRUD routes follow the same pattern for every resource in your app
- Middleware runs before your route handlers -- for logging, CORS, auth, and more
- The order of middleware matters: logger, then CORS, then auth, then routes

## AI-Powered Development with Claude Code

This is the most important chapter in this entire guidebook. Everything else we have covered -- the terminal, JavaScript, React, Git, databases, APIs -- those are the ingredients. This chapter is where you learn to cook.

Claude Code is the single biggest force multiplier in your toolkit. It is an AI coding assistant that lives in your terminal, understands your entire codebase, and can write code, create files, run commands, and fix bugs -- all from plain English instructions. Learning to use it well is the difference between spending a weekend building one page and spending a weekend building an entire application.

### What Is Vibe Coding?

In early 2025, Andrej Karpathy -- one of the most respected AI researchers in the world, a co-founder of OpenAI who previously led Tesla's AI division -- posted something that changed how people think about software development:

> There's a new kind of coding I call "vibe coding", where you fully give in to the vibes, embrace exponentials, and forget that the code even exists... It's not really coding -- I just see stuff, say stuff, run stuff, and copy paste stuff, and it mostly works.

Vibe coding is the idea that you can build real, working software by describing what you want in plain English and letting an AI assistant handle the actual code. You focus on the *what* -- the features, the design, the user experience. The AI handles the *how* -- the syntax, the boilerplate, the implementation details.

This is not science fiction. This is how a growing number of professional developers work right now. And it is how you are going to build your first real projects.

### But Here Is the Catch

Vibe coding does not mean you can be clueless. The developers who get the best results from AI tools are the ones who understand what they are building. That is exactly why we spent the previous seven chapters building your foundation. When Claude Code writes a React component that fetches data from a Supabase API, you should have a mental picture of what is happening -- even if you could not write it from scratch yourself.

You do not need to be an expert. You need to be literate. And after the previous chapters, you are.

Think of it this way: you do not need to know how to build a car engine to be an excellent driver. But you do need to know what the steering wheel, brakes, and gas pedal do. That is where you are right now -- and Claude Code is about to put you in the driver's seat of a very fast car.

### Why This Chapter Is Different

Every other chapter taught you a concept. This chapter teaches you a workflow -- the actual day-to-day process of building software with an AI partner. By the end, you will not just understand Claude Code. You will have a repeatable system for turning ideas into working applications.

Let's get started.

## Getting Started with Claude Code

You have your terminal open. You have a project folder. Now it is time to meet the tool that is going to change how you think about building software.

### What Is Claude Code?

Claude Code is an AI coding assistant made by Anthropic. Unlike chatbots that live in a browser window, Claude Code lives directly in your terminal -- the same place where you run `git`, `npm`, and all your other developer tools. This is not a toy. This is a professional-grade tool used by real developers at real companies to build real products.

Here is what makes it different from just chatting with an AI:

- **It can read your entire codebase.** When you start Claude Code inside a project folder, it understands your files, your folder structure, your dependencies, and how everything connects.
- **It can create and edit files.** Claude Code does not just suggest code in a chat window -- it actually writes to your filesystem, creating new files and modifying existing ones.
- **It can run terminal commands.** Need to install a package, run your dev server, or execute a database migration? Claude Code can do it right from the conversation.
- **It remembers context within a session.** As you go back and forth, it keeps track of what you have discussed and what files it has touched.

Imagine you had a brilliant senior developer sitting right next to you at your desk. They have already read every single file in your project. They know your tech stack inside and out. They never get tired, never get annoyed at "dumb" questions, and they can type about 100 times faster than you.

That is Claude Code. It is not replacing you -- you are still the one deciding what to build and why. But it handles the heavy lifting of turning your ideas into actual code. You are the architect drawing the blueprint. Claude Code is the construction crew that builds it.

### How to Start a Session

If you followed the setup in Chapter 1, Claude Code is already installed. Starting it is as simple as navigating to your project and typing one word:

```bash
# Navigate to your project folder
cd my-project

# Start Claude Code
claude
```

That is it. When Claude Code starts, it does a few things behind the scenes:

1. **Scans your project structure** -- it reads your folder layout, file names, and key configuration files like `package.json`, `tsconfig.json`, and any `CLAUDE.md` file.
2. **Understands your tech stack** -- it figures out you are using Next.js, Supabase, Tailwind, or whatever your project is built with.
3. **Opens a conversation** -- you see a prompt where you can type in plain English what you want to do.

From that point on, you just talk to it. No special syntax. No programming language. Just describe what you want.

Always start Claude Code from the root of your project folder -- the one that contains your `package.json`. If you start it from the wrong directory, it will not have the full picture of your codebase and its suggestions will be less accurate. Think of it like giving someone a map but tearing off half of it first. Not helpful.

### Your Very First Prompt

Here is the moment. Claude Code is running. The cursor is blinking. What do you type?

Start simple. Do not try to build your entire application in one message. A great first prompt is one that helps you understand your own project.

That is not a throwaway step. Even if you created the project yourself, this prompt teaches you something important: *Claude Code can see your entire project at once.* It can connect dots between files that you might not have connected yet. Use that superpower early and often.

Notice how specific that prompt is. It tells Claude Code *what* to create, *where* it should go, *what it should say*, and *how to style it*. That specificity is the whole game, and we will go much deeper into it in the prompting section.

### What a Session Looks Like

A typical Claude Code session is a conversation. You do not write one giant prompt and walk away. You build iteratively, one step at a time:

1. **You ask** -- "Create a navigation bar with links to Home, About, and Contact."
2. **Claude Code responds** -- it shows you what files it wants to create or modify, and asks for confirmation.
3. **You approve** -- Claude Code makes the changes.
4. **You check your browser** -- you see the result.
5. **You refine** -- "Make the nav bar sticky so it stays at the top when I scroll."
6. **Claude Code updates** -- it modifies the existing file.
7. **Repeat** until you are happy.

This back-and-forth loop is the heartbeat of vibe coding. Each iteration gets you closer to what you want. You are steering, and Claude Code is driving.

### Ending a Session

When you are done, you can type `/exit` or just close the terminal. Your files are saved to disk like any normal file -- Claude Code does not hold them hostage. Everything it created or modified is right there in your project folder, ready to be committed with Git.

## What Claude Code Can Do

Most people start using Claude Code for one thing -- writing code. But that is just the tip of the iceberg. Claude Code is a general-purpose development partner that can handle nearly every task in the software development lifecycle. Once you understand the full range of what it can do, you will find yourself reaching for it constantly.

### The Big Eight

Here are the eight core capabilities that you will use every single day.

1. **Write Features** -- Describe a feature in plain English and Claude Code builds it -- components, pages, API routes, database queries, all of it.
2. **Fix Bugs** -- Paste an error message and Claude Code reads the relevant files, identifies the root cause, and applies the fix.
3. **Refactor Code** -- Ask it to restructure existing code -- extract components, rename variables, split large files, or modernize patterns.
4. **Create Files** -- Generate entire file structures -- new pages, components, API routes, configuration files, database migrations.
5. **Explain Code** -- Point it at any file or function and get a clear, beginner-friendly explanation of what the code does and why.
6. **Write Tests** -- Tell it what to test and it writes the test files, imports, mocks, and assertions -- ready to run.
7. **Debug Errors** -- Give it an error and context about what you were doing. It traces the problem through your codebase and fixes it.
8. **Deploy Apps** -- It can run deploy commands, set up configurations, and walk you through getting your app live on the internet.

### Beyond the Big Eight

Here are a few more things Claude Code handles well that you might not expect:

- **Git operations** -- "Commit my changes with a descriptive message" or "Create a new branch called feature/user-auth"
- **Code reviews** -- "Look at the changes I have made and tell me if there are any issues"
- **Documentation** -- "Add JSDoc comments to all the functions in this file"
- **Performance** -- "This page loads slowly. Can you look at the data fetching and suggest improvements?"
- **Accessibility** -- "Check this form for accessibility issues and fix them"
- **Styling iterations** -- "Make this card look more modern" or "Add hover effects to the navigation links"

The more you use Claude Code, the more you will discover what it can do. The limit is usually your imagination, not the tool.

Claude Code is not just for writing code. One of the most powerful things you can do is use it to *understand* code. Whenever you come across something confusing -- whether it is code Claude Code wrote or code in a tutorial -- just ask it to explain. "What does this do? Why is it written this way? What would happen if I changed this?" There is no dumb question. The AI never judges you, and every explanation makes you a better developer.

## Writing Great Prompts

If there is one page in this entire book that you come back to again and again, let it be this one.

The quality of what Claude Code builds depends entirely on how well you describe what you want. A vague prompt produces vague results. A specific, well-structured prompt produces code that works the first time. This is not a nice-to-have skill -- it is *the* skill of AI-powered development. A developer who writes great prompts will outproduce a developer who writes mediocre ones by a factor of ten, every single day.

The good news is that writing great prompts is a learnable skill. You do not need to be a programmer to do it. You need to be a clear thinker and a specific communicator. And that is something you can practice.

### The Three Principles

Every great prompt follows three principles: be specific, provide context, and iterate. Let's break each one down.

**Principle 1: Be Specific, Not Vague**

The number one mistake people make with AI is being too vague. "Make a dashboard" could mean a thousand different things. Claude Code is powerful, but it cannot read your mind. The more detail you provide, the closer the first attempt will be to what you actually want.

Here is the rule of thumb: **if two different developers could read your prompt and imagine completely different results, the prompt is too vague.**

**Principle 2: Provide Context**

Claude Code can see your files, but it does not know your intentions, your business rules, or what you tried before. Context turns a good prompt into a great one.

Context includes:

- **What already exists** -- "I have a users table in Supabase with name, email, and role columns"
- **What tech to use** -- "Use Supabase auth helpers for Next.js"
- **What should happen after** -- "After login, redirect to /dashboard"
- **What patterns to follow** -- "Use the same card component style as the settings page"
- **What went wrong before** -- "I tried this but got a hydration error"

**Principle 3: Iterate, Do Not Monologue**

This is where most beginners go wrong. They try to describe an entire feature in one massive prompt -- the database schema, the API routes, the frontend components, the styling, the error handling, all at once. This almost always produces worse results than building step by step.

Think of it like giving directions. You would not say "Go to the grocery store, then the bank, then pick up my dry cleaning, then stop at the pharmacy, then get gas, and here are the specific items I need at each stop." You would give one destination at a time.

### The Progressive Building Approach

Here is the workflow I use on every project, and the one I want you to adopt. I call it **progressive building** -- you start with the simplest possible version and layer on complexity one prompt at a time.

Let's say you want to build a blog. Here is how a beginner might prompt:

> "Build a complete blog with user authentication, post creation with a rich text editor, categories, tags, comments, likes, a search bar, an admin dashboard, and deploy it to Vercel."

That prompt will produce chaos. Too many moving parts, too many decisions for the AI to make at once, too many places for things to go wrong.

Here is how an experienced vibe coder would approach the exact same project:

**Session 1: The skeleton**
- "Create a Next.js page at /blog that displays a hardcoded list of 3 blog post titles."
- "Make each title a link that goes to /blog/[slug]."
- "Create the dynamic route page that shows a hardcoded title and body."

**Session 2: Real data**
- "Create a posts table migration with title, slug, content, and created_at."
- "Create a PostDAO that fetches all posts and a single post by slug."
- "Update the /blog page to fetch real posts from Supabase instead of the hardcoded list."

**Session 3: Creating posts**
- "Create a /blog/new page with a form to create a new post."
- "Add a PostService with a createPost method that validates the title is not empty and auto-generates the slug."
- "Connect the form to the API."

**Session 4: Polish**
- "Add loading states to the blog list and individual post pages."
- "Add error handling if a post slug does not exist."
- "Style the blog with proper typography and spacing."

Each session produces working, testable code. You never have a half-broken app with twelve things wrong at once. You always have a working version to fall back on. And every Git commit captures a stable state.

That is the secret. Not one giant prompt. Many small, focused ones.

The quality of what Claude builds depends entirely on how well you describe what you want. I know I keep saying this, but it is the most important lesson in this entire book. Prompting is a skill, and like any skill, you get better with practice. Your first prompts will be messy. That is fine. A month from now, you will write prompts that produce working features on the first try. The only way to get there is to write a lot of prompts and pay attention to what works and what does not.

### Common Prompting Mistakes

Watch out for these patterns that trip up beginners:

**Over-specifying implementation details you do not care about.** If you do not have a preference about whether a variable is called `userData` or `userInfo`, do not specify it. Focus your detail budget on the things that matter to you -- the user experience, the data structure, the behavior.

**Under-specifying things you do care about.** If you want the button to be exactly blue with white text, say so. If you want the form to redirect after submission, say so. Claude Code does not know which details matter to you unless you tell it.

**Asking for too many things at once.** If your prompt has more than three or four distinct tasks, break it up. One clear task per prompt produces better results than five tasks crammed together.

**Not giving context about errors.** "It does not work" is the most useless thing you can say. *What* does not work? *What* did you expect to happen? *What* happened instead? *What error message* did you see? The more diagnostic information you provide, the faster Claude Code can help.

**Forgetting to check the result.** After every prompt, look at what Claude Code produced. Read the code. Test it in the browser. Check for things that do not look right. The iteration cycle only works if you actually verify each step.

## The CLAUDE.md File

Every time you start a new Claude Code session, it is like Claude Code is joining your project for the first time. It can read your files and figure out a lot on its own, but it does not know your preferences, your conventions, or the decisions you have already made. That is where `CLAUDE.md` comes in.

### What Is CLAUDE.md?

`CLAUDE.md` is a special markdown file you place at the root of your project. Claude Code reads it automatically at the start of every session. It contains everything Claude Code needs to know about your project that it could not figure out just by reading the code.

Think of it as your project's instruction manual for the AI.

Imagine you are hiring a brilliant developer to join your project. On their first day, you sit down with them and say: "Here is our tech stack. Here is how we name files. Here is our database setup. Here are the patterns we follow. Here are the things we never do."

That conversation takes an hour, and you only have to do it once -- they remember it going forward.

CLAUDE.md is that conversation, written down. Except instead of having it once with a human, you have it at the start of *every* Claude Code session. It gives Claude Code the same institutional knowledge that a long-time team member would have. Without it, you end up repeating yourself: "No, we use arrow functions." "No, we use kebab-case filenames." "No, we always include deleted_at columns." With it, Claude Code just knows.

### Why It Matters

Without a `CLAUDE.md`, every session starts from scratch. Claude Code might:

- Use a different naming convention than your project follows
- Choose a library you do not use
- Structure files differently than the rest of your codebase
- Miss a pattern you follow religiously
- Create code that technically works but does not fit your project

With a good `CLAUDE.md`, Claude Code produces code that looks like *you* wrote it. It follows your conventions, uses your preferred libraries, and structures things the way your project expects. The first version of every feature is closer to what you actually want, which means less back-and-forth.

### What to Include

A great `CLAUDE.md` covers four areas:

**1. Project Overview**
A brief description of what the project is and what it does. This gives Claude Code the big picture.

**2. Tech Stack**
The specific frameworks, libraries, and tools your project uses. Be explicit about versions if it matters.

**3. Conventions**
How you name things, how you structure files, what patterns you follow. This is where most of the value lives.

**4. Rules and Boundaries**
Things Claude Code should never do, common mistakes to avoid, and hard requirements.

### A Complete Template

Here is a `CLAUDE.md` template you can adapt for any project. You do not need to fill out every section on day one -- start with the basics and add more as your project grows.

```markdown
# CLAUDE.md

## Project Overview
This is [what your app does] built with [your tech stack].

## Tech Stack
- Frontend: Next.js 15 (App Router) with TypeScript
- Styling: Tailwind CSS v4
- Database: Supabase (PostgreSQL)
- API: Hono
- Auth: Supabase Auth
- Testing: Vitest
- Deployment: Vercel

## Architecture
- Follow 3-layer pattern: DAO (database) -> Service (logic) -> API Route (HTTP)
- DAOs go in src/dao/
- Services go in src/services/
- API routes go in src/app/api/

## Conventions
- Use functional components with arrow functions
- Use TypeScript interfaces (not types) for object shapes
- Name files in kebab-case: user-profile.tsx
- Name components in PascalCase: UserProfile
- Always handle loading and error states in components

## Database Rules
- All tables have RLS enabled
- Use UUID for primary keys
- Include created_at and updated_at on every table
- Include deleted_at for soft deletes -- never use hard deletes
- Always filter with WHERE deleted_at IS NULL

## Do NOT
- Use inline styles -- always use Tailwind classes
- Use default exports -- always use named exports
- Skip error handling on API routes
- Use any -- always define proper TypeScript types
```

This is a starting point. Your `CLAUDE.md` will be unique to your project. Add to it whenever you catch Claude Code doing something you do not want -- instead of correcting it every time, add the rule to `CLAUDE.md` and it will follow it in every future session.

### Growing Your CLAUDE.md Over Time

Your `CLAUDE.md` is not a document you write once and forget. It evolves with your project. Here is how it grows:

**Week 1:** Basic tech stack and file conventions. Maybe 20 lines.

**Week 4:** You have added rules about database naming, component structure, and your preferred error handling pattern. Maybe 50 lines.

**Month 2:** You have a detailed document covering architecture, testing patterns, deployment instructions, and common pitfalls. Maybe 100 lines.

**Month 6:** Your `CLAUDE.md` is a comprehensive guide that any developer (human or AI) could use to understand and contribute to your project. It is one of the most valuable files in your repository.

Every time Claude Code does something unexpected or wrong, ask yourself: "Could I have prevented this with a line in CLAUDE.md?" If the answer is yes, add it. That is how the best `CLAUDE.md` files are built -- one correction at a time.

### A CLAUDE.md Is Also Good for Humans

Here is a bonus insight: a well-written `CLAUDE.md` is not just useful for Claude Code. It is useful for any developer who joins your project -- including future you. Six months from now, when you come back to a project you have not touched in a while, your `CLAUDE.md` is the fastest way to remember how everything works.

Good documentation helps everyone. The fact that Claude Code reads it is just a bonus.

A good CLAUDE.md saves you from repeating yourself in every single prompt. Every time you find yourself saying "No, use Tailwind, not inline styles" or "No, put that in the dao folder, not the components folder" -- that is a sign you need to add a rule to your CLAUDE.md. Over time, it becomes a living document that encodes all your project's institutional knowledge. The ten minutes you spend maintaining it saves hours of correction.

## Advanced Patterns

You know the basics now. You can start Claude Code, write decent prompts, and build features step by step. This section covers the patterns that separate someone who uses Claude Code from someone who is *effective* with Claude Code. These are the lessons that usually take months of trial and error to learn. You are getting them on day one.

### Multi-File Changes: Claude Code's Superpower

Most coding tasks touch more than one file. Adding a new feature might require a database migration, a DAO, a service, an API route, a React component, and an update to the navigation menu. Doing this by hand means juggling six files, keeping them all consistent, and remembering to import things in the right places.

Claude Code handles multi-file changes in a single interaction. This is arguably its biggest advantage over traditional development. You describe the feature once, and Claude Code creates or modifies every file that needs to change -- all wired together correctly.

The key to making multi-file changes work well is to describe the *feature*, not the individual files. Tell Claude Code what you want the user to experience, and let it figure out which files need to change.

### The Debugging Workflow

Bugs are inevitable. Here is a systematic workflow for using Claude Code to squash them fast.

**Step 1: Capture the error.** Copy the entire error message, including the stack trace (the list of files and line numbers). The more information you provide, the faster Claude Code can find the problem.

**Step 2: Describe what you expected.** "I clicked the submit button and expected the form to save and redirect to the dashboard."

**Step 3: Describe what actually happened.** "Instead, the page just refreshes and the data is not saved."

**Step 4: Hand it to Claude Code.**

**Step 5: Verify the fix.** After Claude Code makes the change, test it yourself. Click the button again. Make sure the bug is actually gone and that the fix did not break something else.

This five-step process works for almost every bug. The most important part is step 1 -- a complete error message with a stack trace gives Claude Code an enormous head start.

### The 80/20 Rule of AI Coding

This is one of the most important concepts in this entire chapter, so pay close attention.

Claude Code will get you 80% of the way to a working feature very quickly. In minutes, it can scaffold a complete feature with database tables, API routes, and frontend components. That 80% feels amazing. It is fast, it is impressive, and it is easy.

The remaining 20% is where your judgment matters:

- **Understanding why the code works.** Can you explain what each file does and how they connect? If not, ask Claude Code to explain.
- **Edge cases.** What happens if the user submits an empty form? What if the database is down? What if two users try to do the same thing at the same time?
- **Security.** Is the API route checking that the user is authenticated? Is user input being sanitized? Are there any SQL injection risks?
- **Performance.** Is the code fetching too much data? Are there unnecessary re-renders? Could a database query be optimized?
- **Business logic correctness.** Does the feature actually do what the business needs it to do? Claude Code does not know your business rules unless you tell it.

That last 20% is why you spent the previous seven chapters learning fundamentals. The AI gets you to 80% fast. Your knowledge and judgment close the gap.

:::caution[Always Review AI-Generated Code]
Never deploy code you do not understand. After every Claude Code session, read through the code it generated. Ask yourself: "Do I understand what this does? Does it handle errors? Is it secure?" If the answer to any of these is "no" or "I am not sure," ask Claude Code to explain it. Understanding the code is not optional -- it is your responsibility as the developer. The AI is your co-pilot, but you are the one flying the plane.
:::

### When to NOT Trust Claude Code

Claude Code is remarkably capable, but it has blind spots. Knowing when to be skeptical is a skill that separates good developers from reckless ones.

**Security-sensitive code.** Authentication, authorization, payment processing, and anything involving user data. Always review these with extra scrutiny. Claude Code might produce code that works but has subtle security flaws -- like forgetting to check permissions on an API route, or not sanitizing user input before a database query.

**Business logic.** Claude Code does not understand your business. If you are building an invoicing system and there is a rule that invoices over $10,000 require manager approval, Claude Code will not know that unless you tell it. Complex business rules should always be verified by someone who understands the domain.

**Complex database operations.** Migrations that modify existing data, multi-step transactions, and queries that involve many joins. These are areas where a subtle bug can corrupt your data. Always review the SQL and test with sample data before running migrations in production.

**Performance-critical code.** Claude Code tends to write code that is correct but not necessarily optimized. If you are building something that handles thousands of requests per second or processes large datasets, you need to think about performance yourself.

**The "it works on my machine" trap.** Claude Code tests nothing. It writes code that *looks* correct and often *is* correct, but it has not run the code, clicked the buttons, or verified the edge cases. That is your job. Every feature Claude Code builds should be tested by you before you consider it done.

Never ship code you do not understand. I know I sound like a broken record, but this is the one rule that matters more than any other in this entire book. If Claude Code writes something and you cannot explain what it does to a friend, you are not ready to ship it. Ask Claude Code to explain it. Read it line by line. Understand it. Then ship it. That extra ten minutes of review will save you from bugs, security holes, and the embarrassment of deploying something that falls apart in production.

### Pattern: The Review Prompt

One of the most powerful advanced patterns is the review prompt. After Claude Code builds a feature, ask it to review its own work.

This is free quality assurance. It takes ten seconds and catches real bugs. Make it a habit.

### Pattern: The Explanation Prompt

When you finish a feature, ask Claude Code to teach you what it built.

This turns every coding session into a learning session. You are not just getting features built -- you are getting a private tutoring session at the same time.

### Putting It All Together

Here is the complete workflow of an advanced Claude Code user:

1. **Plan first.** Think about what you want to build before you type anything. Write down the user story: "As a user, I want to favorite posts so I can find them easily later."
2. **Build incrementally.** Start with the database, then the API, then the UI. One prompt per layer.
3. **Verify each step.** Check the database migration. Test the API with a quick request. Load the UI in the browser.
4. **Review the code.** Ask Claude Code to self-review. Read through the code yourself.
5. **Understand what was built.** Ask Claude Code to explain anything you do not understand.
6. **Commit with Git.** Save your working state before moving on to the next feature.

That cycle -- plan, build, verify, review, understand, commit -- is how professional software gets made. The only difference is that with Claude Code, each cycle takes minutes instead of hours.

### Chapter 8 Recap

- Claude Code is a terminal-based AI that reads your codebase and builds features from plain English
- The quality of its output depends on the quality of your prompts -- be specific, provide context, iterate
- Build incrementally: one small, focused prompt at a time, not one massive prompt
- CLAUDE.md gives Claude Code permanent memory about your project's conventions and rules
- Claude Code gets you 80% of the way fast -- your judgment handles the critical remaining 20%
- Never ship code you do not understand. Always review, always test, always ask questions

## Deploying Your Application

Building an app on your computer is great. You can click around, test things, show it to whoever is in the room. But here is the truth: until your app is on the internet, it is just a project on your hard drive. Deployment is when it becomes *real*.

Deployment is the process of taking the code on your machine and running it on a server that is always online -- so anyone in the world with a link can use what you built. And the best part? Modern tools have made this shockingly easy. We are not talking about renting servers and configuring Linux. You can go from "it works on my laptop" to "here is the live URL" in under five minutes.

Think of all the work you have done so far as rehearsal. You have been practicing on a stage with no audience -- your localhost. Deployment is opening night. The curtains go up, the lights come on, and suddenly real people are watching. The good news is that unlike a live play, if something goes wrong you can fix it instantly and redeploy. No one will throw tomatoes.

### How to Approach This Chapter

This is a short chapter, but it is an important one. Deploying is the finish line for every project. Once you understand how it works, you will deploy early and often -- and that habit will make you a much better developer. Let's get your code on the internet.

The first time I deployed something to the internet and sent the URL to a friend, I was grinning like an idiot. There is something deeply satisfying about typing a URL into a browser on a completely different computer and seeing *your* thing show up. You are about to feel that. Enjoy it.

## Deployment Platforms

Before you deploy, you need to pick where your app is going to live. The good news is that there are several excellent platforms, all with generous free tiers. The even better news is that you do not have to manage servers, install operating systems, or do any of that old-school operations work.

When a band rehearses, they play in a garage or a small practice room. The music is real, but no one else can hear it. Deployment is booking the venue, setting up the sound system, and opening the doors. The music is the same -- your code does not change -- but now the whole world can experience it. Each platform below is a different venue, and they all handle the sound system for you.

### The Big Four

- **Vercel:** Made by the same team that built Next.js. If you are building with Next.js, this is the easiest choice. The free tier is generous, it deploys automatically from GitHub, and everything just works out of the box. This is what we recommend for your first deployment.
- **Cloudflare Pages & Workers:** Excellent for Hono APIs and static sites. Cloudflare runs your code on their global edge network, meaning your app loads fast no matter where in the world someone visits from. Great for APIs and lightweight apps.
- **Railway:** A good all-purpose platform for full-stack apps and databases. If you need to run background jobs, host a database, or deploy something that is not a Next.js app, Railway handles it well. Think of it as the Swiss Army knife option.
- **Netlify:** A solid alternative to Vercel with a great free tier. Netlify works well for static sites, Jamstack apps, and serverless functions. Some developers prefer its interface and workflow.

### Which One Should You Pick?

Here is the simple answer: **start with Vercel**. Since you are building with Next.js, Vercel is designed specifically for your stack. It requires the least configuration and gives you the fastest path to a live URL.

As you grow and build different kinds of projects, you will naturally explore the others. A Hono API might go on Cloudflare Workers. A full-stack app with a hosted database might go on Railway. But for now, Vercel is your go-to.

### How Deployment Actually Works

Here is the flow:

1. You write code on your computer and push it to GitHub.
2. Your deployment platform watches your GitHub repo for changes.
3. When it sees a new push, it pulls the code, builds your app, and starts serving it.
4. Your app gets a URL that anyone can visit.

That is it. No FTP. No SSH. No configuring Apache or Nginx. Push your code and the platform handles the rest.

When I started building websites, deploying meant connecting to a server with FTP (a file transfer tool), manually uploading files, and praying nothing broke. It took hours and was terrifying every time. Today you push to GitHub and your app is live in under a minute. You are living in the golden age of web development. Do not take it for granted.

## Deploying to Vercel

This is it. The moment your app goes from "works on my computer" to "works on the internet." Follow these steps and you will have a live URL in about five minutes.

### Step by Step

1. **Push your code to GitHub.**

   If you have been following along, your project is already a Git repository connected to GitHub. Make sure all your latest changes are committed and pushed. If you are not sure, run `git status` in your terminal. If it says "nothing to commit, working tree clean," you are good.

2. **Go to vercel.com and sign in with GitHub.**

   Head to [vercel.com](https://vercel.com) and click "Sign Up" or "Log In." Choose the "Continue with GitHub" option. This connects your Vercel account to your GitHub repos so Vercel can access your code.

3. **Click "Add New..." and select "Project."**

   On your Vercel dashboard, click the "Add New..." button and select "Project." You will see a list of your GitHub repositories. Find the one you want to deploy and click "Import."

4. **Configure your project settings.**

   Vercel automatically detects that it is a Next.js project and fills in the right build settings. You usually do not need to change anything here. If your app uses environment variables (like Supabase keys), add them now -- we will cover this in the next section.

5. **Click Deploy.**

   Hit that Deploy button. Vercel will pull your code, install dependencies, build your app, and deploy it. You can watch the build logs in real time. In about a minute, you will see a success screen with your live URL.

That is the whole process. Five steps. Your app is now on the internet.

### Continuous Deployment

Here is where it gets even better. From now on, every time you push new code to your `main` branch on GitHub, Vercel automatically deploys the new version. You do not have to go through those steps again. Push your code, and within a minute or two your live site is updated.

This is called **continuous deployment**, and it is how professional teams work. You make a change, push it, and it goes live. No manual uploading. No "did I remember to deploy?" anxiety. It just happens.

Even better: if you push to a branch that is *not* main (like a feature branch), Vercel creates a **preview deployment** -- a temporary URL where you can test the changes before merging them into main. This is incredibly useful for checking that things look right before going live.

Deploy early and deploy often. Do not wait until your app is "perfect" to put it online. Deploying early catches problems you would never find on localhost -- things like missing environment variables, broken image paths, or API routes that do not work in production. The sooner you deploy, the sooner you find and fix those issues. Ship it.

## Environment Variables in Production

Remember the `.env.local` file we set up earlier? The one with your Supabase URL, API keys, and other secrets? That file only exists on your computer. When Vercel builds and deploys your app, it does not have that file. So your app will break -- unless you tell Vercel about those variables.

### Why .env.local Does Not Work in Production

Your `.env.local` file is intentionally excluded from Git (it is listed in `.gitignore`). This is on purpose. You never, ever want your secrets pushed to GitHub where anyone could see them. But that means when Vercel pulls your code from GitHub, those values are not there.

You need to add your environment variables directly in Vercel's dashboard.

### How to Add Environment Variables in Vercel

1. Go to your project on [vercel.com](https://vercel.com).
2. Click **Settings** in the top navigation.
3. Click **Environment Variables** in the sidebar.
4. For each variable in your `.env.local` file, type the name (like `NEXT_PUBLIC_SUPABASE_URL`) and paste in the value.
5. Click **Save**.

That is it. Vercel will use these values the next time it builds your app. If you already deployed before adding them, just push a new commit (or click "Redeploy" in the Vercel dashboard) to trigger a fresh build.

Other platforms like Railway, Netlify, and Cloudflare all have similar settings pages. The concept is the same everywhere: do not put secrets in your code, put them in the platform's dashboard.

:::danger[Never Hardcode Secrets]
Do not put API keys, database passwords, or any other secrets directly in your code. Not in a variable. Not in a comment. Not "just for now." If it ends up in Git, it ends up in your Git history forever -- even if you delete it later. Always use environment variables.
:::

Here is a real story: when I was starting out, I accidentally pushed a database password to GitHub. Within *minutes*, automated bots found it and tried to use it. I had to rotate every credential in the project. It took hours. Learn from my mistake -- environment variables exist for a reason. Use them.

## Thinking Like a Developer

Here is something nobody tells you when you start learning to code: the hardest part is not the code. The syntax, the frameworks, the tools -- those are learnable. The hard part is the *thinking*. Learning how to break a problem into smaller pieces. Knowing what to do when something does not work. Staying motivated when everything feels confusing.

This chapter is about the stuff that does not fit into a code editor. It is about the mindset, the habits, and the skills that separate someone who *knows some code* from someone who *thinks like a developer*. These are the things I wish someone had told me when I was starting out.

Knowing how to drive does not make you a mechanic. And knowing how to use a wrench does not mean you can diagnose why an engine is making a weird noise. The best mechanics are not the ones who memorized every tool -- they are the ones who know how to *listen*, how to systematically isolate the problem, and how to stay calm when the first three things they try do not work. That is what this chapter is about. Not the tools. The thinking.

### What This Chapter Covers

- **The Art of Debugging** -- A systematic approach to finding and fixing bugs. Spoiler: it is detective work.
- **How to Learn Effectively** -- The habits and strategies that actually accelerate your growth as a developer.
- **Project Ideas** -- Real things to build, organized by difficulty, with prompts to get you started.
- **Essential Resources** -- The best YouTube channels, websites, and practice platforms to keep you learning.

I have been writing software for a long time, and I still Google things every day. I still get stuck. I still write code that does not work on the first try. The difference between a beginner and an experienced developer is not that the experienced developer stops making mistakes -- it is that they have gotten very good at recovering from them. That is the skill this chapter helps you build.

### One More Thing

This is the final chapter of the book. But it is not the end of anything. It is the starting line. Everything you have learned so far -- the web, JavaScript, React, databases, APIs, deployment -- those are your tools. This chapter is about what you do with them. Let's finish strong.

## The Art of Debugging

Every developer, from the absolute beginner to the senior engineer at Google, spends a huge chunk of their time debugging. It is not a sign that you are bad at coding. It is the *actual job*. Writing code that works on the first try is rare. Writing code, finding out it does not work, figuring out why, and fixing it? That is programming.

Bugs are not failures. They are puzzles. Every bug is a mystery waiting to be solved, and solving them is one of the most satisfying feelings in programming. Change the way you think about bugs and you will enjoy coding a lot more.

Imagine you are a detective arriving at a crime scene. You do not just guess who did it and make an arrest. You look at the evidence. You interview witnesses. You narrow down suspects one by one until you find the culprit.

Debugging works the same way. The error message is your first piece of evidence. The code is the crime scene. Console logs are your interviews with witnesses. And you eliminate possibilities systematically until the bug has nowhere left to hide.

The worst thing you can do is panic and start changing random things. That is like a detective randomly arresting people and hoping one of them is guilty. Be methodical.

### The 6-Step Debugging Process

1. **Read the error message carefully.**

   This sounds obvious, but most beginners skip this step. Error messages are written to tell you exactly what went wrong and where. Read the whole thing. Look for the file name, the line number, and the description of the problem. Nine times out of ten, the answer is right there in the error message.

2. **Reproduce the bug consistently.**

   If you cannot make the bug happen on demand, you cannot fix it. Click the same button, submit the same form, visit the same page. Figure out exactly what causes the issue. If it only happens sometimes, try to identify the pattern. What is different when it breaks versus when it works?

3. **Isolate the problem.**

   The bug is hiding somewhere in your code. Your job is to narrow down where. Comment out sections of code until the error goes away. Then uncomment them one at a time until the error comes back. The last thing you uncommented contains the bug. This feels slow, but it is the fastest way to find the problem.

4. **Check your assumptions.**

   Are you sure that variable has the value you think it does? Are you sure that function is being called? Add `console.log()` statements to verify what is actually happening. More bugs come from wrong assumptions than wrong syntax. Print everything. Trust the output, not your memory.

5. **Search the error message online.**

   Copy the error message, paste it into Google or a search engine, and look at the results. Someone has almost certainly hit the exact same error before. Stack Overflow, GitHub issues, and forum posts are full of solutions. You are not the first person to encounter this problem.

6. **Ask Claude Code.**

   Paste the error message and the relevant code into Claude Code. Give it context: what you were trying to do, what happened instead, and what you have already tried. Claude Code is excellent at diagnosing issues because it can see patterns across millions of codebases.

### Common Bug Categories

Here are the bugs you will encounter most often:

- **Typos.** A misspelled variable name, a missing comma, a lowercase letter where there should be uppercase. Your editor's red squiggles are your first line of defense.
- **Undefined values.** You tried to use something that does not exist yet. This usually means the data has not loaded, the variable was never assigned, or you are accessing the wrong property.
- **Async timing.** You tried to use data before it finished loading. The database call takes time, but your code tried to use the result immediately.
- **Wrong types.** You passed a string where a number was expected, or an object where an array was expected. TypeScript catches a lot of these, which is why we use it.
- **Missing imports.** You used a function or component but forgot to import it at the top of the file. The error message for this one is usually very clear.

When I am stuck on a bug for more than 30 minutes, I take a walk. I am not kidding. Some of my best debugging breakthroughs have happened in the shower or while making coffee. Your brain keeps working on the problem in the background. If you are spinning your wheels, step away. You will come back with fresh eyes.

## How to Learn Effectively

There is a difference between *studying* programming and *learning* programming. You can watch a hundred tutorials and still not be able to build anything on your own. Real learning happens when you struggle, get stuck, figure things out, and build things that are yours. This section is about the habits that actually make you grow.

### Build Projects, Not Just Tutorials

Tutorials are step one. They show you how something works in a controlled environment where everything goes smoothly. That is useful for getting started. But real learning happens when you close the tutorial and try to build something *without* hand-holding.

The moment you try to build your own project, you will hit problems the tutorial never covered. That is the point. Every problem you solve on your own is a lesson that sticks permanently. Tutorials teach you the notes. Building projects teaches you how to play music.

### Get Comfortable Being Stuck

This is the most important thing in this entire chapter, so read it twice: **feeling stuck is not a sign that you are bad at this. It is a sign that you are learning.**

Every developer in the world has stared at their screen feeling completely lost. The difference between those who make it and those who quit is simple: the ones who make it keep going. They accept that confusion is temporary, that the answer is findable, and that being stuck is just part of the process.

If you are never stuck, you are not challenging yourself enough. The edge of your knowledge -- that uncomfortable zone where things feel hard and unclear -- is exactly where growth happens.

You do not build muscle by lifting weights that are easy. You build muscle by pushing yourself to the point where it is hard, resting, and coming back. Learning to code works the same way. If it feels hard, that means it is working. If everything always feels easy, you are just going through the motions.

### Read Other People's Code

Browse GitHub repositories of projects you admire. Open up the source code and just *read*. You will see how experienced developers structure their projects, name their variables, organize their files, and solve problems you have not even thought of yet.

You do not need to understand every line. Just reading real code written by skilled developers trains your eye for quality. Over time, you start recognizing good patterns and bad patterns instinctively.

### Teach What You Learn

Here is a trick that works insanely well: when you learn something new, explain it to someone else. Write a blog post, make a short video, or just explain it to a friend. The act of teaching forces you to truly understand something. If you cannot explain it simply, you do not understand it well enough yet.

You do not need an audience. Even writing it down for yourself counts. The act of putting it into words is what matters.

### Take Breaks

Your brain solves problems in the background. Many of the biggest breakthroughs in programming happen *after* stepping away from the screen. If you have been grinding for hours and nothing is clicking, close your laptop. Go for a walk. Play a game. Sleep on it.

This is not laziness. This is how your brain works. It needs downtime to process and connect ideas. Some of my best solutions have come to me while doing absolutely nothing related to code.

I used to think being a great developer meant grinding through code for 12 hours straight. I was wrong. The best developers I know work in focused bursts, take real breaks, and protect their sleep. Your brain is your tool. Take care of it the way a carpenter takes care of their saw.

I want you to remember one thing: talent is overrated. The people who become great developers are not the ones who were born smart. They are the ones who showed up every day, built things, broke things, fixed things, and kept going. You have everything you need to do this. Trust the process.

## Project Ideas to Build

The best way to learn is by building real things. Not hypothetical things. Not things from a tutorial where someone holds your hand through every step. Real things that you choose, that you care about, and that force you to solve problems nobody gave you the answer to.

Here are projects organized by difficulty. Each one comes with a Claude Code prompt to get you started. Pick one that sounds interesting and go build it.

### Beginner Projects

**Personal Portfolio Website**

Build a site that shows off who you are and what you have built. Use Next.js and Tailwind CSS. Include an about page, a projects page, and a contact section. This is the first thing any developer should build -- and it gives you a real URL to share with people.

**To-Do List App**

The classic starter project, but with a twist: start with local storage, then upgrade to Supabase so your tasks persist across devices. This teaches you state management, CRUD operations, and the difference between local and server-side storage.

**Weather App**

Use a free weather API to show current weather and a forecast for any city. This teaches you how to fetch data from external APIs and display it in a nice UI.

### Intermediate Projects

**Blog Platform**

Build a blog where users can sign up, write posts in Markdown, and publish them. This covers authentication, CRUD operations, Markdown rendering, and user-specific data. It is a serious project that teaches you a ton.

**Expense Tracker**

Build an app to track spending with categories, charts, and date filtering. This is a practical tool you could actually use every day, which makes it a great learning project.

**Recipe Collection App**

Build a place to save your favorite recipes with search, categories, and a favorites feature. This is great practice for building a content-heavy app with good UX.

### Advanced Projects

**Real-Time Chat Application**

Build a messaging app where users can chat in real time using Supabase Realtime. This teaches you real-time data subscriptions, websockets, and how to handle data that changes live.

**Restaurant Management System**

Build a system for managing restaurant menus, orders, and inventory. This is a multi-feature app that mimics real business software.

**SaaS Starter**

Build the foundation of a software-as-a-service app with authentication, billing, and multi-tenant architecture. This is the kind of project that teaches you how real products are built.

Do not try to build the perfect project on your first attempt. Build the ugly version first. Get it working. Then improve it. Then improve it again. Every version teaches you something the last one did not. The developers with the best portfolios are not the ones who built perfect things -- they are the ones who built lots of things and kept getting better.

## Essential Resources

You do not have to learn everything from one place. In fact, the best developers pull from a mix of sources -- a YouTube video here, a documentation page there, a coding challenge to test themselves. Here are the resources I recommend. Bookmark the ones that look interesting and come back to them as you grow.

### YouTube Channels

These creators are some of the best teachers on the internet. They explain complex topics clearly and keep things engaging.

- **[Fireship](https://www.youtube.com/@Fireship)** -- Fast, information-dense videos on modern web dev concepts. His '100 Seconds' series is legendary.
- **[Traversy Media](https://www.youtube.com/@TraversyMedia)** -- Excellent crash courses and tutorials for every framework. Great for getting up to speed quickly.
- **[Web Dev Simplified](https://www.youtube.com/@WebDevSimplified)** -- Clear explanations of complex concepts. Perfect when something is just not clicking.
- **[The Net Ninja](https://www.youtube.com/@NetNinja)** -- Structured tutorial series on every major framework. Start-to-finish courses you can follow along with.
- **[Jack Herrington](https://www.youtube.com/@jherr)** -- Advanced React and Next.js patterns. Come here when you are ready to level up your architecture.
- **[Theo (t3.gg)](https://www.youtube.com/@t3dotgg)** -- Opinionated deep dives on the modern web ecosystem. Great for understanding why things are the way they are.

### Websites and Documentation

When you need to understand something deeply, written documentation is your best friend. These are the sites I go back to constantly.

- **[freeCodeCamp](https://www.freecodecamp.org)** -- Free, structured curriculum with certifications. Thousands of hours of lessons and projects.
- **[The Odin Project](https://www.theodinproject.com)** -- Free, comprehensive web dev curriculum. Opinionated and project-based. One of the best free resources out there.
- **[javascript.info](https://javascript.info)** -- The best free JavaScript reference on the internet. Clear, thorough, and well-organized.
- **[react.dev](https://react.dev)** -- The official React documentation. Completely rewritten and genuinely excellent. Start with the 'Learn' section.
- **[MDN Web Docs](https://developer.mozilla.org)** -- The encyclopedia of web standards. When you need to know exactly how something works in the browser, this is where you go.

### Practice Platforms

Reading and watching only get you so far. These platforms give you hands-on challenges to sharpen your skills.

- **[LeetCode](https://leetcode.com)** -- Algorithm challenges ranked by difficulty. Great for building problem-solving skills, especially if you want to prepare for job interviews later.
- **[Exercism](https://exercism.org)** -- Language-specific exercises with mentoring. Pick a language and work through progressively harder challenges.
- **[Frontend Mentor](https://www.frontendmentor.io)** -- Real-world frontend design challenges. You get a design file and build it. Excellent for practicing CSS and responsive layouts.
- **[Codewars](https://www.codewars.com)** -- Fun coding challenges organized by difficulty. The gamification makes it addictive in the best way.

The best developers are not the ones who know the most. They are the ones who build the most. Do not get stuck in tutorial hell -- watching video after video without ever building anything. Use these resources as fuel, not as a substitute for building.

### You Made It

If you have read through this entire book, I want you to know something: I am proud of you. Seriously. Most people talk about learning to code. Most people save a YouTube playlist and never watch it. Most people start a tutorial and never finish. You did the work. You showed up.

You now know how the web works. You understand JavaScript and TypeScript. You can build user interfaces with React and Next.js. You can store data in a real database. You can build APIs. You can use AI tools to code faster than developers could dream of ten years ago. And you can deploy what you build for the whole world to see.

That is not nothing. That is a *foundation*. A foundation you can build anything on.

The path forward is simple: **pick a project, start building, and do not stop**. You will get stuck. You will break things. You will feel lost. And every single time, you will figure it out -- because that is what developers do.

Start small. Ship often. Keep learning.

Now go build something.

### The Junior Developer Guidebook: Complete Recap

- You learned how the web works: clients, servers, and the request-response cycle.
- You learned JavaScript and TypeScript -- the languages that power the modern web.
- You learned Git so you never lose your work and can collaborate with others.
- You learned React and Next.js to build real user interfaces.
- You learned databases and Supabase to store data permanently.
- You learned how to build APIs that connect your frontend to your backend.
- You learned how to use Claude Code as your AI pair programmer.
- You deployed your app to the internet for the world to see.
- And you learned the mindset that will carry you through everything else.
